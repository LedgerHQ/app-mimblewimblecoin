"use strict";class Crypto{static deriveChildKey(e,t){return new Promise((function(r,i){var n=e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),E=e.subarray(Crypto.CHAIN_CODE_LENGTH),c=new Promise((function(e,t){e([n.slice(0),E.slice(0)])})),a=[c];for(let e=0;e<t.length;++e)c=c.then((function(r){return new Promise((function(i,n){var E=r[Crypto.SECRET_KEY_INDEX],c=r[Crypto.CHAIN_CODE_INDEX];return Crypto.deriveSecretKeyAndChainCode(E,c,t[e]).then((function(e){E.fill(0),c.fill(0),i(e)})).catch((function(e){E.fill(0),c.fill(0),n(e)}))}))})).catch((function(e){return new Promise((function(t,r){r(e)}))})),a.push(c);return Promise.all(a).then((function(e){var t=e[e.length-1][Crypto.SECRET_KEY_INDEX],n=e[e.length-1][Crypto.CHAIN_CODE_INDEX],E=Common.mergeArrays([t,n]);t.fill(0),n.fill(0),!0===Secp256k1Zkp.isValidSecretKey(E.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH))?r(E):(E.fill(0),i("Invalid extended private key."))})).catch((function(e){i(e)}))}))}static commit(e,t,r,i){return new Promise((function(n,E){return Crypto.deriveSecretKey(e,t,r,i).then((function(e){var r=Secp256k1Zkp.pedersenCommit(e,t.toFixed());r!==Secp256k1Zkp.OPERATION_FAILED?n(r):(e.fill(0),E("Performing Pedersen commit failed."))})).catch((function(e){E(e)}))}))}static commitAmount(e){var t=Secp256k1Zkp.pedersenCommit(Crypto.ZERO_BLINDING_FACTOR,e.toFixed());if(t!==Secp256k1Zkp.OPERATION_FAILED)return t;throw"Performing Pedersen commit failed."}static proof(e,t,r,i,n){return new Promise((function(E,c){return Crypto.commit(e,t,r,i).then((function(a){return Crypto.deriveSecretKey(e,t,r,i).then((function(e){return n.rewindNonce(a).then((function(o){return n.privateNonce(a).then((function(a){try{var _=n.proofMessage(r,i)}catch(t){return e.fill(0),o.fill(0),a.fill(0),void c("Getting proof message failed.")}var l=Secp256k1Zkp.createBulletproof(e,t.toFixed(),o,a,new Uint8Array([]),_);l!==Secp256k1Zkp.OPERATION_FAILED?(e.fill(0),o.fill(0),a.fill(0),E(l)):(e.fill(0),o.fill(0),a.fill(0),c("Getting bulletproof failed."))})).catch((function(t){e.fill(0),o.fill(0),c(t)}))})).catch((function(t){e.fill(0),c(t)}))})).catch((function(e){c(e)}))})).catch((function(e){c(e)}))}))}static deriveSecretKey(e,t,r,i){return new Promise((function(n,E){for(var c=new Uint32Array(r.getDepth()),a=0;a<r.getDepth();++a)c[a]=r.getPaths()[a];return Crypto.deriveChildKey(e,c).then((function(e){var r=e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH).slice(0);if(e.fill(0),i===Crypto.SWITCH_TYPE_NONE)n(r);else if(i===Crypto.SWITCH_TYPE_REGULAR){var c=Secp256k1Zkp.blindSwitch(r,t.toFixed());if(c===Secp256k1Zkp.OPERATION_FAILED)return r.fill(0),void E("Performing blind switch failed.");r.fill(0),!0===Secp256k1Zkp.isValidSecretKey(c)?n(c):(c.fill(0),E("Blind switch isn't a valid secret key."))}else r.fill(0),E("Invalid switch type.")})).catch((function(e){E(e)}))}))}static signatureMessage(e){var t=Blake2b.compute(Crypto.SINGLE_SIGNER_MESSAGE_LENGTH,e,new Uint8Array([]));if(t!==Blake2b.OPERATION_FAILED)return t;throw"Creating signature message failed."}static rootPublicKey(e){return new Promise((function(t,r){var i=e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),n=Secp256k1Zkp.publicKeyFromSecretKey(i);n!==Secp256k1Zkp.OPERATION_FAILED?t(n):r("Getting public key failed.")}))}static addressKey(e,t){return new Promise((function(r,i){return Crypto.deriveSecretKey(e,Crypto.ADDRESS_KEY_AMOUNT,new Identifier(Identifier.ROOT_SERIALIZED_IDENTIFIER),Crypto.SWITCH_TYPE_REGULAR).then((function(e){return crypto.subtle.importKey("raw",(new TextEncoder).encode(Crypto.ADDRESS_KEY_SEED),{name:Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,hash:{name:Crypto.ADDRESS_KEY_DIGEST_ALGORITHM}},!1,["sign"]).then((function(n){return crypto.subtle.sign(Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,n,e).then((function(n){e.fill(0);var E=(n=new Uint8Array(n)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),c=n.subarray(Crypto.CHAIN_CODE_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(E))return Crypto.deriveSecretKeyAndChainCode(E,c,t).then((function(e){n.fill(0),e[Crypto.CHAIN_CODE_INDEX].fill(0),r(e[Crypto.SECRET_KEY_INDEX])})).catch((function(e){n.fill(0),i(e)}));n.fill(0),i("Secret key is not a valid secret key.")})).catch((function(t){e.fill(0),i(t)}))})).catch((function(t){e.fill(0),i(t)}))})).catch((function(e){i(e)}))}))}static get SWITCH_TYPE_NONE(){return 0}static get SWITCH_TYPE_REGULAR(){return Crypto.SWITCH_TYPE_NONE+1}static get SECP256K1_SECRET_KEY_LENGTH(){return 32}static get SECP256K1_PUBLIC_KEY_LENGTH(){return 33}static get BLINDING_FACTOR_LENGTH(){return 32}static get COMMIT_LENGTH(){return 33}static get SINGLE_SIGNER_SIGNATURE_LENGTH(){return 64}static get SINGLE_SIGNER_MESSAGE_LENGTH(){return 32}static get MAXIMUM_PROOF_LENGTH(){return 5134}static get ZERO_BLINDING_FACTOR(){return new Uint8Array(Crypto.BLINDING_FACTOR_LENGTH).fill(0)}static get ED25519_PUBLIC_KEY_LENGTH(){return 32}static get ED25519_SIGNATURE_LENGTH(){return 64}static get MAXIMUM_MESSAGE_HASH_SIGNATURE_LENGTH(){return 72}static get NONCE_LENGTH(){return 32}static get TAU_X_LENGTH(){return 32}static deriveSecretKeyAndChainCode(e,t,r){return new Promise((function(i,n){return crypto.subtle.importKey("raw",t,{name:Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,hash:{name:Crypto.CHAIN_CODE_DIGEST_ALGORITHM}},!1,["sign"]).then((function(t){if(!0===Identifier.isPathHardened(r))var E=Common.mergeArrays([new Uint8Array([0]),e]);else if((E=Secp256k1Zkp.publicKeyFromSecretKey(e))===Secp256k1Zkp.OPERATION_FAILED)return void n("Getting public key from secret key failed.");var c=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT);new DataView(c).setUint32(0,r,!1);var a=Common.mergeArrays([E,new Uint8Array(c)]);return E.fill(0),crypto.subtle.sign(Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,t,a).then((function(t){a.fill(0);var r=(t=new Uint8Array(t)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(r)){var E=Secp256k1Zkp.secretKeyTweakAdd(r,e);if(E===Secp256k1Zkp.OPERATION_FAILED)return t.fill(0),void n("Performing secret key tweak add failed.");if(!0===Secp256k1Zkp.isValidSecretKey(E)){var c=t.subarray(Crypto.CHAIN_CODE_LENGTH).slice(0);t.fill(0),i([E,c])}else t.fill(0),E.fill(0),n("Updated secret key is not a valid secret key.")}else t.fill(0),n("New secret key is not a valid secret key.")})).catch((function(e){a.fill(0),n("Creating new extended private key failed.")}))})).catch((function(e){n("Creating crypto key failed.")}))}))}static get CHAIN_CODE_LENGTH(){return 32}static get SECRET_KEY_INDEX(){return 0}static get CHAIN_CODE_INDEX(){return Crypto.SECRET_KEY_INDEX+1}static get CHAIN_CODE_ENCRYPTION_ALGORITHM(){return"HMAC"}static get CHAIN_CODE_DIGEST_ALGORITHM(){return"SHA-512"}static get ADDRESS_KEY_AMOUNT(){return new BigNumber(713)}static get ADDRESS_KEY_SEED(){return"Grinbox_seed"}static get ADDRESS_KEY_ENCRYPTION_ALGORITHM(){return"HMAC"}static get ADDRESS_KEY_DIGEST_ALGORITHM(){return"SHA-512"}}