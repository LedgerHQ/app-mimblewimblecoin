<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">

	<script src="BLAKE2b.min.js"></script>
	<script src="Ed25519.min.js"></script>
	<script src="X25519.min.js"></script>
	<script src="LedgerJS-6.11.2.min.js"></script>
	<script src="secp256k1-zkp.min.js"></script>
	<script src="bignumber.js-9.0.1.min.js"></script>
	<script src="js-sha3-0.8.0.min.js"></script>
	<script src="js-sha256-0.9.0.min.js"></script>
	<script src="hi-base32-0.5.1.min.js"></script>
	<script src="ChaCha-2.1.0.min.js"></script>
	<script src="common.min.js"></script>
	<script src="identifier.min.js"></script>
	<script src="crypto.min.js"></script>
	<script src="seed.min.js"></script>
	<script src="tor.min.js"></script>
	<script src="mqs.min.js"></script>
	<script src="slatepack.min.js"></script>
	<script src="consensus.min.js"></script>
	<script src="base58.min.js"></script>
	<script src="proof_builder.min.js"></script>
	<script src="new_proof_builder.min.js"></script>
	<script src="slate.min.js"></script>
	<script src="slate_kernel.min.js"></script>
	
	<script>
	
		// Use strict
		"use strict";
		
	
		// Constants
		
		// Request class
		const REQUEST_CLASS = 0xC7;
		
		// Request get application information instruction
		const REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION = 0;

		// Request get root public key instruction
		const REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION = REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION + 1;

		// Request get public key verification instruction
		const REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION = REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION + 1;

		// Request get seed cookie instruction
		const REQUEST_GET_SEED_COOKIE_INSTRUCTION = REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION + 1;

		// Request get commitment instruction
		const REQUEST_GET_COMMITMENT_INSTRUCTION = REQUEST_GET_SEED_COOKIE_INSTRUCTION + 1;

		// Request get bulletproof components instruction
		const REQUEST_GET_BULLETPROOF_COMPONENTS_INSTRUCTION = REQUEST_GET_COMMITMENT_INSTRUCTION + 1;

		// Request get Tor public key instruction
		const REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION = REQUEST_GET_BULLETPROOF_COMPONENTS_INSTRUCTION + 1;

		// Request get Tor transaction signature instruction
		const REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION = REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION + 1;

		// Request get Tor certificate signature instruction
		const REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION = REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION + 1;

		// Request start encrypting Slatepack data instruction
		const REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION + 1;

		// Request continue encrypting Slatepack data instruction
		const REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request finish encrypting Slatepack data instruction
		const REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request start decrypting Slatepack data instruction
		const REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request continue decrypting Slatepack data instruction
		const REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request finish decrypting Slatepack data instruction
		const REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request get MQS public key instruction
		const REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION = REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request get MQS transaction signature instruction
		const REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION = REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION + 1;

		// Request start encrypting MQS data instruction
		const REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION + 1;

		// Request continue encrypting MQS data instruction
		const REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request finish encrypting MQS data instruction
		const REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request start decrypting MQS data instruction
		const REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request continue decrypting MQS data instruction
		const REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request finish decrypting MQS data instruction
		const REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request start transaction instruction
		const REQUEST_START_TRANSACTION_INSTRUCTION = REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request continue transaction include output instruction
		const REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION = REQUEST_START_TRANSACTION_INSTRUCTION + 1;

		// Request continue transaction include input instruction
		const REQUEST_CONTINUE_TRANSACTION_INCLUDE_INPUT_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION + 1;

		// Request continue transaction apply offset instruction
		const REQUEST_CONTINUE_TRANSACTION_APPLY_OFFSET_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_INCLUDE_INPUT_INSTRUCTION + 1;

		// Request continue transaction get public key instruction
		const REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_APPLY_OFFSET_INSTRUCTION + 1;

		// Request finish transaction instruction
		const REQUEST_FINISH_TRANSACTION_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION + 1;
		
		// No parameter
		const NO_PARAMETER = 0;
		
		// Text delimiter
		const TEXT_DELIMITER = 0;
		
		// Mnemonic
		const MNEMONIC = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		
		// Seed key
		const SEED_KEY = "IamVoldemort";
		
		// Account
		const ACCOUNT = new BigNumber(0);
		
		// Response delimiter length
		const RESPONSE_DELIMITER_LENGTH = (new Uint8Array([0x00, 0x00]))["length"];
		
		// Tor address key index
		const TOR_ADDRESS_KEY_INDEX = 0;
		
		// MQS address key index
		const MQS_ADDRESS_KEY_INDEX = 0;
		
		// Tor sender address type
		const TOR_SENDER_ADDRESS_TYPE = 0;
		
		// MQS sender address type parameter
		const MQS_SENDER_ADDRESS_TYPE = TOR_SENDER_ADDRESS_TYPE + 1;
		
		// No payment proof type
		const NO_PAYMENT_PROOF_TYPE = 0;
		
		// Tor payment proof type
		const TOR_PAYMENT_PROOF_TYPE = NO_PAYMENT_PROOF_TYPE + 1;
		
		// MQS payment proof type
		const MQS_PAYMENT_PROOF_TYPE = TOR_PAYMENT_PROOF_TYPE + 1;
		
		
		// Main function
		window.addEventListener("load", async function() {
		
			// Initialize BLAKE2b
			await Blake2b.initialize();
			
			// Initialize Ed25519
			await Ed25519.initialize();
			
			// Initialize X25519
			await X25519.initialize();
			
			// Initialize secp256k1-zkp
			await Secp256k1Zkp.initialize();
			
			// Get form
			let form = document.querySelector("form");
			
			// Get button
			let button = document.querySelector("button");
			
			// Form submit event
			form.addEventListener("submit", async function(event) {
			
				// Prevent default
				event.preventDefault();
			
				// Disable button
				button["disabled"] = true;
				
				// Change button's text
				button["textContent"] = "Runningâ€¦";
				
				// Get transport method
				let transportMethod = document.querySelector("input:checked")["value"];
				
				// Try
				try {
				
					// Check transport method
					switch(transportMethod) {
					
						// USB
						case "USB":
						
							// Connect to the hardware wallet using USB
							var hardwareWallet = await TransportWebUSB.create();
						
							// Break
							break;
						
						// Bluetooth
						case "Bluetooth":
						
							// Connect to the hardware wallet using Bluetooth
							var hardwareWallet = await BluetoothTransport.create();
						
							// Break
							break;
						
						// HTTP
						case "HTTP":
						
							// Connect to the hardware wallet using HTTP
							var hardwareWallet = await HttpTransport().open("http://localhost:9998");
							
							// Break
							break;
					}
				
					// Log message
					console.log("Running tests with the mnemonic: " + MNEMONIC);
					
					// Initialize seed
					let seed = new Seed();
					await seed.initialize(MNEMONIC);
					
					// Get the extended private key from the seed
					let extendedPrivateKey = await seed.getExtendedPrivateKey(SEED_KEY);
					
					// Run get application information test
					await getApplicationInformationTest(hardwareWallet);
					
					// Run get root public key test
					await getRootPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get public key verification test
					await getPublicKeyVerificationTest(hardwareWallet, extendedPrivateKey);
					
					// Run get seed cookie test
					await getSeedCookieTest(hardwareWallet, extendedPrivateKey);
					
					// Run get commitment test
					await getCommitmentTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE);
					await getCommitmentTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR);
					
					// Run get bulletproof test
					await getBulletproofTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE);
					await getBulletproofTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR);
					
					// Run get Tor public key test
					await getTorPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get Tor transaction signature test
					await getTorTransactionSignatureTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE);
					await getTorTransactionSignatureTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR);
					
					// Run get Tor certificate signature test
					await getTorCertificateSignatureTest(hardwareWallet, extendedPrivateKey);
					
					// Run encrypt Slatepack data test
					await encryptSlatepackDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run decrypt Slatepack data test
					await decryptSlatepackDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run get MQS public key test
					await getMqsPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get MQS transaction signature test
					await getMqsTransactionSignatureTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE);
					await getMqsTransactionSignatureTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR);
					
					// Run encrypt MQS data test
					await encryptMqsDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run decrypt MQS data test
					await decryptMqsDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run receive transaction test
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT);
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)));
					await receiveTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)));
					
					// Run send transaction test
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.COINBASE_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.PLAIN_FEATURES, Slate.NO_LOCK_HEIGHT, SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.HEIGHT_LOCKED_FEATURES, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), SlateKernel.NO_RELATIVE_HEIGHT, MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, NO_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), TOR_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), MQS_SENDER_ADDRESS_TYPE, TOR_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_NONE, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					await sendTransactionTest(hardwareWallet, extendedPrivateKey, Crypto.SWITCH_TYPE_REGULAR, SlateKernel.NO_RECENT_DUPLICATE_FEATURES, Slate.NO_LOCK_HEIGHT, new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER)), MQS_SENDER_ADDRESS_TYPE, MQS_PAYMENT_PROOF_TYPE);
					
					// Log message
					console.log("Passed running all tests");
				}
				
				// Catch errors
				catch(error) {
				
					// Log error
					console.log(error);
					
					// Log message
					console.log("Running tests failed");
				}
				
				// Change button's text
				button["textContent"] = "Run";
				
				// Enable button
				button["disabled"] = false;
			});
			
			// Change button's text
			button["textContent"] = "Run";
			
			// Enable button
			button["disabled"] = false;
		});
		
		
		// Supporting function implementation
		
		// Get application information test
		async function getApplicationInformationTest(hardwareWallet) {
		
			// Log message
			console.log("Running get application information test");
		
			// Get the application information from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Get application name from the response
			let applicationNameDelimiter = findTextDelimiter(response);
			let applicationName = (new TextDecoder()).decode(response.subarray(0, applicationNameDelimiter));
			
			// Log application name
			console.log("Application name: " + applicationName);
			
			// Get application version from the response
			let applicationVersionDelimiter = findTextDelimiter(response.subarray(applicationNameDelimiter + [TEXT_DELIMITER]["length"]));
			let applicationVersion = (new TextDecoder()).decode(response.subarray(applicationNameDelimiter + [TEXT_DELIMITER]["length"]).subarray(0, applicationVersionDelimiter));
									
			// Log application version
			console.log("Application version: " + applicationVersion);
			
			// Log message
			console.log("Passed getting application information test");		
		}
		
		// Get root public key test
		async function getRootPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get root public key test");
			
			// Requestor
			const REQUESTOR = "Test " + Math.random().toString();
			
			// Log requestor
			console.log("Using requestor: " + REQUESTOR);
		
			// Get the expected root public key from the extended private key
			let expectedRootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Log message
			console.log("Confirm exporting the root public key");
			
			// Get the root public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
															
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Requestor
				Buffer.from(REQUESTOR)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log root public key
			console.log("Root public key: " + Common.toHexString(response));
			
			// Check if root public key is invalid
			if(Common.arraysAreEqual(response, expectedRootPublicKey) === false) {
			
				// Throw error
				throw "Invalid root public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting root pubic key test");	
		}
		
		// Get public key verification test
		async function getPublicKeyVerificationTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get public key verification test");
			
			// Root public key parameter
			const ROOT_PUBLIC_KEY_PARAMETER = 0;
			
			// Tor public key parameter
			const TOR_PUBLIC_KEY_PARAMETER = ROOT_PUBLIC_KEY_PARAMETER + 1;
			
			// MQS public key parameter
			const MQS_PUBLIC_KEY_PARAMETER = TOR_PUBLIC_KEY_PARAMETER + 1;
			
			// Get the root public key from the extended private key
			let rootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Log message
			console.log("Verify that the root public key is: " + Common.toHexString(rootPublicKey));
			
			// Get root public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, ROOT_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor address from the Tor public key
			let torAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Log message
			console.log("Verify that the Tor public key is: " + torAddress);
			
			// Get Tor public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, TOR_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS address from the MQS public key
			let mqsAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Log message
			console.log("Verify that the MQS public key is: " + mqsAddress);
			
			// Get MQS public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, MQS_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Log message
			console.log("Passed getting pubic key verification test");
		}
		
		// Get seed cookie test
		async function getSeedCookieTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get seed cookie test");
			
			// Get the root public key from the extended private key
			let rootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Get the expected seed cookie from the root public key
			let expectedSeedCookie = new Uint8Array(await crypto["subtle"].digest("SHA-512", rootPublicKey));
			
			// Get seed cookie from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_SEED_COOKIE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log seed cookie
			console.log("Seed cookie: " + Common.toHexString(response));
			
			// Check if seed cookie is invalid
			if(Common.arraysAreEqual(response, expectedSeedCookie) === false) {
			
				// Throw error
				throw "Invalid seed cookie: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting seed cookie test");
		}
		
		// Get commitment test
		async function getCommitmentTest(hardwareWallet, extendedPrivateKey, switchType) {
		
			// Log message
			console.log("Running get commitment test");
			
			// Amount
			const AMOUNT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Identifier
			const IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Log amount
			console.log("Using amount: " + AMOUNT.toFixed());
			
			// Log identifier
			console.log("Using identifier: " + Common.toHexString(IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Get the expected commitment from the extended private key, amount, identifier, and switch type
			let expectedCommitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, switchType);
			
			// Get commitment from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_COMMITMENT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([switchType]))
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log commitment
			console.log("Commitment: " + Common.toHexString(response));
			
			// Check if commitment is invalid
			if(Common.arraysAreEqual(response, expectedCommitment) === false) {
			
				// Throw error
				throw "Invalid commitment: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting commitment test");
		}
		
		// Get bulletproof test
		async function getBulletproofTest(hardwareWallet, extendedPrivateKey, switchType) {
		
			// Log message
			console.log("Running get bulletproof test");
			
			// Amount
			const AMOUNT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Identifier
			const IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Log amount
			console.log("Using amount: " + AMOUNT.toFixed());
			
			// Log identifier
			console.log("Using identifier: " + Common.toHexString(IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Initialize proof builder with the extended private key
			let proofBuilder = new NewProofBuilder();			
			await proofBuilder.initialize(extendedPrivateKey);
			
			// Get expected bulletproof from the extended private key, amount, identifier, switch type, and proof builder
			let expectedBulletproof = await Crypto.proof(extendedPrivateKey, AMOUNT, IDENTIFIER, switchType, proofBuilder);
			
			// Get bulletproof components from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_BULLETPROOF_COMPONENTS_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([switchType]))
			]));
			
			// Get tau x from response
			let tauX = response.subarray(0, Crypto.TAU_X_LENGTH);
			
			// Get t one from response
			let tOne = response.subarray(Crypto.TAU_X_LENGTH, Crypto.TAU_X_LENGTH + Crypto.SECP256K1_PUBLIC_KEY_LENGTH);
			
			// Get t two from response
			let tTwo = response.subarray(Crypto.TAU_X_LENGTH + Crypto.SECP256K1_PUBLIC_KEY_LENGTH, Crypto.TAU_X_LENGTH + Crypto.SECP256K1_PUBLIC_KEY_LENGTH + Crypto.SECP256K1_PUBLIC_KEY_LENGTH);
			
			// Get commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, switchType);
			
			// Get rewind nonce from the proof builder and the commitment
			let rewindNonce = await proofBuilder.rewindNonce(commitment);
			
			// Get proof message from identifier and switch type
			let proofMessage = proofBuilder.proofMessage(IDENTIFIER, switchType);
			
			// Create bulletproof with the tau x, t one, t two, commit, amount, rewind nonce, and proof message
			let bulletproof = Secp256k1Zkp.createBulletproofBlindless(tauX, tOne, tTwo, commitment, AMOUNT.toFixed(), rewindNonce, new Uint8Array([]), proofMessage);
			
			// Log commitment
			console.log("Bulletproof: " + Common.toHexString(bulletproof));
			
			// Check if commitment is invalid
			if(Common.arraysAreEqual(bulletproof, expectedBulletproof) === false) {
			
				// Throw error
				throw "Invalid bulletproof: " + Common.toHexString(bulletproof);
			}
			
			// Log message
			console.log("Passed getting bulletproof test");
		}
		
		// Get Tor public key test
		async function getTorPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get Tor public key test");
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get expected Tor public key from the Tor private key
			let expectedTorPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get the Tor public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor public key
			console.log("Tor public key: " + Common.toHexString(response));
			
			// Check if Tor public key is invalid
			if(Common.arraysAreEqual(response, expectedTorPublicKey) === false) {
			
				// Throw error
				throw "Invalid Tor public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting Tor pubic key test");	
		}
		
		// Get Tor transaction signature test
		async function getTorTransactionSignatureTest(hardwareWallet, extendedPrivateKey, switchType) {
		
			// Log message
			console.log("Running get Tor transaction signature test");
			
			// Amount
			const AMOUNT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Identifier
			const IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Log amount
			console.log("Using amount: " + AMOUNT.toFixed());
			
			// Log identifier
			console.log("Using identifier: " + Common.toHexString(IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Get the commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, switchType);
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor sender address from the Tor public key
			let torSenderAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Get transaction message from amount, commitment, and Tor sender address
			let transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, torSenderAddress);
			
			// Get the expected Tor transaction signature from the transaction message and Tor private key
			let expectedTorTransactionSignature = Ed25519.sign(transactionMessage, torPrivateKey);
			
			// Get the Tor transaction signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(torSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor transaction signature
			console.log("Tor transaction signature with Tor sender address: " + Common.toHexString(response));
			
			// Check if Tor transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedTorTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid Tor transaction signature: " + Common.toHexString(response);
			}
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS sender address from the MQS public key
			let mqsSenderAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Get transaction message from amount, commitment, and MQS sender address
			transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, mqsSenderAddress);
			
			// Get the expected Tor transaction signature from the transaction message and Tor private key
			expectedTorTransactionSignature = Ed25519.sign(transactionMessage, torPrivateKey);
			
			// Get the Tor transaction signature from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(mqsSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor transaction signature
			console.log("Tor transaction signature with MQS sender address: " + Common.toHexString(response));
			
			// Check if Tor transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedTorTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid Tor transaction signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting Tor transaction signature test");	
		}
		
		// Get Tor certificate signature test
		async function getTorCertificateSignatureTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get Tor certificate signature test");
			
			// Certificate header length
			const CERTIFICATE_HEADER_LENGTH = 32;
			
			// Certificate expiration offset
			const CERTIFICATE_EXPIRATION_OFFSET = CERTIFICATE_HEADER_LENGTH + 2;
			
			// Certificate public key offset
			const CERTIFICATE_PUBLIC_KEY_OFFSET = CERTIFICATE_HEADER_LENGTH + 7;
			
			// Certificate signing public key offset
			const CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET = CERTIFICATE_HEADER_LENGTH + 44;
			
			// Certificate signature offset
			const CERTIFICATE_SIGNATURE_OFFSET = CERTIFICATE_HEADER_LENGTH + 76;
			
			// Certificate expiration to epoch time scalar
			const CERTIFICATE_EXPIRATION_TO_EPOCH_TIME_SCALAR = 60 * 60;
			
			// Certificate (contents of an ed25519_signing_cert file created with the command `tor --keygen --SigningKeyLifetime '6 months'`)
			const CERTIFICATE = Common.fromHexString("3d3d206564323535313976312d636572743a207479706534203d3d0000000000010400070003019e5fd5f3a704fb52aa3e54a835e12ae102d0b44b785f239467a1523ffd4582410100200400b3ee07b33145c47278e7f35468247a4d13905595fe98a533f1b5120609229429fafef1e44a3f25add4570fb3bd0806a9b6a6afeaf32fffd3a40152e5abb6e763069e76ceec0b4027d8a88e37443d304ef963003d44c48c27235f71494778d60d");
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Replace signing public key in certificate with the Tor public key
			let certificate = Common.mergeArrays([CERTIFICATE.subarray(0, CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET), torPublicKey, CERTIFICATE.subarray(CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET + torPublicKey["length"])]);
			
			// Log certificate
			console.log("Using certificate: " + Common.toHexString(CERTIFICATE));
			
			// Get the expected Tor certificate signature from the certificate and Tor private key
			let expectedTorCertificateSignature = Ed25519.sign(certificate.subarray(CERTIFICATE_HEADER_LENGTH, CERTIFICATE_SIGNATURE_OFFSET), torPrivateKey);
			
			// Get certification's expiration
			let expiration = certificate.subarray(CERTIFICATE_EXPIRATION_OFFSET, CERTIFICATE_EXPIRATION_OFFSET + Uint32Array["BYTES_PER_ELEMENT"]).slice().reverse();
			
			// Get expiration as a timestamp
			let expirationTimestamp = (new Uint32Array(expiration["buffer"]))[0] * CERTIFICATE_EXPIRATION_TO_EPOCH_TIME_SCALAR;
			
			// Get timestamp as a date
			let expirationDate = (new Date(expirationTimestamp * Common.MILLISECONDS_IN_A_SECOND));
			
			// Log message
			console.log("Verify that the certificate expires on: " + expirationDate.getUTCHours().toFixed().padStart(2, "0") + ":" + expirationDate.getUTCMinutes().toFixed().padStart(2, "0") + ":" + expirationDate.getUTCSeconds().toFixed().padStart(2, "0") + " on " + expirationDate.getUTCFullYear().toFixed() + "-" + (expirationDate.getUTCMonth() + 1).toFixed().padStart(2, "0") + "-" + expirationDate.getUTCDate().toFixed().padStart(2, "0") + " UTC");
			
			// Log message
			console.log("Verify that the certificate's public key is: " + Common.toHexString(certificate.subarray(CERTIFICATE_PUBLIC_KEY_OFFSET, CERTIFICATE_PUBLIC_KEY_OFFSET + Crypto.ED25519_PUBLIC_KEY_LENGTH)));
			
			// Get the Tor certificate signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Certificate
				Buffer.from(certificate.subarray(CERTIFICATE_HEADER_LENGTH, CERTIFICATE_SIGNATURE_OFFSET))
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor certificate signature
			console.log("Tor certificate signature: " + Common.toHexString(response));
			
			// Check if Tor certificate signature is invalid
			if(Common.arraysAreEqual(response, expectedTorCertificateSignature) === false) {
			
				// Throw error
				throw "Invalid Tor certificate signature: " + Common.toHexString(response);
			}
			
			// Log signed Tor certificate
			console.log("Signed Tor certificate: " + Common.toHexString(certificate.subarray(0, CERTIFICATE_SIGNATURE_OFFSET)) + Common.toHexString(response));
			
			// Log message
			console.log("Passed getting Tor certificate signature test");	
		}
		
		// Encrypt Slatepack data test
		async function encryptSlatepackDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running encrypt Slatepack data test");
			
			// Data
			const DATA = crypto.getRandomValues(new Uint8Array(Math.round(Math.random() * Common.BYTE_MAX_VALUE)));
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// Log data
			console.log("Using data: " + Common.toHexString(DATA));
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get Tor private key from the random private key
			let otherTorPrivateKey = await Crypto.addressKey(Common.mergeArrays([privateKey, crypto.getRandomValues(new Uint8Array(Crypto.CHAIN_CODE_LENGTH))]), TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let otherTorPublicKey = Ed25519.publicKeyFromSecretKey(otherTorPrivateKey);
			
			// Start encrypting Slatepack data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(otherTorPublicKey)
			]));
			
			// Get nonce from response
			let nonce = response.subarray(0, Slatepack.NONCE_LENGTH);
			
			// Go through all chunks of the data
			let encryptedData = new Uint8Array([]);
			for(let i = 0; i <= DATA["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue encrypting Slatepack data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(DATA.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append encrypted data to list
				encryptedData = Common.mergeArrays([encryptedData, response]);
			}
			
			// Finish encrypting Slatepack data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Append tag to encrypted data
			encryptedData = Common.mergeArrays([encryptedData, response]);
			
			// Log encrypted Slatepack data
			console.log("Encrypted Slatepack data: " + Common.toHexString(encryptedData));
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Decrypt the encrypted data
			let decryptedData = await Slatepack.decryptMessage(otherTorPrivateKey, torPublicKey, encryptedData, nonce);
			
			// Log decrypted Slatepack data
			console.log("Decrypted Slatepack data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted Slatepack data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running encrypt Slatepack data test");
		}
		
		// Decrypt Slatepack data test
		async function decryptSlatepackDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running decrypt Slatepack data test");
			
			// Data
			const DATA = crypto.getRandomValues(new Uint8Array(Math.round(Math.random() * Common.BYTE_MAX_VALUE)));
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// AES IV size
			const AES_IV_SIZE = 16;
			
			// Log data
			console.log("Using data: " + Common.toHexString(DATA));
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get Tor private key from the random private key
			let otherTorPrivateKey = await Crypto.addressKey(Common.mergeArrays([privateKey, crypto.getRandomValues(new Uint8Array(Crypto.CHAIN_CODE_LENGTH))]), TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let otherTorPublicKey = Ed25519.publicKeyFromSecretKey(otherTorPrivateKey);
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Encrypt the data
			let encryptedData = await Slatepack.encryptMessage(otherTorPrivateKey, torPublicKey, DATA);
			
			// Get nonce from encrypted data
			let nonce = encryptedData[Slatepack.ENCRYPTED_MESSAGE_NONCE_INDEX];
			
			// Get encrypted message from encrypted data
			let encryptedMessage = encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX];
			
			// Log encrypted Slatepack data
			console.log("Encrypted Slatepack data: " + Common.toHexString(encryptedMessage));
			
			// Remove tag from the encrypted message
			let tag = encryptedMessage.subarray(encryptedMessage["length"] - Slatepack.TAG_LENGTH);
			encryptedMessage = encryptedMessage.subarray(0, encryptedMessage["length"] - Slatepack.TAG_LENGTH);
			
			// Start decrypting Slatepack data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(otherTorPublicKey),
				
				// Nonce
				Buffer.from(nonce),
			]));
			
			// Go through all chunks of the encrypted message
			let decryptedDataChunks = [];
			for(let i = 0; i <= encryptedMessage["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue decrypting Slatepack data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(encryptedMessage.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append decrypted data chunk to list
				decryptedDataChunks.push(response);
			}
			
			// Finish decrypting Slatepack data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(tag));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Create AES key from response
			let aesKey = await crypto["subtle"].importKey("raw", response, {"name": "AES-CBC"}, false, ["decrypt"]);
			
			// Go through all decrypted data chunks
			let decryptedData = new Uint8Array([]);
			for(let i = 0; i < decryptedDataChunks["length"]; ++i) {
			
				// Decrypt the data chunk with the AES key
				let data = new Uint8Array(await crypto["subtle"].decrypt({"name": "AES-CBC", "iv": new Uint8Array(AES_IV_SIZE)}, aesKey, decryptedDataChunks[i]));
				
				// Append decrypted data chunk to list
				decryptedData = Common.mergeArrays([decryptedData, data]);
			}
			
			// Log decrypted Slatepack data
			console.log("Decrypted Slatepack data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted Slatepack data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running decrypt Slatepack data test");
		}
		
		// Get MQS public key test
		async function getMqsPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get MQS public key test");
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get expected MQS public key from the MQS private key
			let expectedMqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get the MQS public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS public key
			console.log("MQS public key: " + Common.toHexString(response));
			
			// Check if MQS public key is invalid
			if(Common.arraysAreEqual(response, expectedMqsPublicKey) === false) {
			
				// Throw error
				throw "Invalid MQS public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting MQS pubic key test");	
		}
		
		// Get MQS transaction signature test
		async function getMqsTransactionSignatureTest(hardwareWallet, extendedPrivateKey, switchType) {
		
			// Log message
			console.log("Running get MQS transaction signature test");
			
			// Amount
			const AMOUNT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Identifier
			const IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Log amount
			console.log("Using amount: " + AMOUNT.toFixed());
			
			// Log identifier
			console.log("Using identifier: " + Common.toHexString(IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Get the commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, switchType);
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS sender address from the MQS public key
			let mqsSenderAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Get transaction message from amount, commitment, and MQS sender address
			let transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, mqsSenderAddress);
			
			// Get transaction message hash from the transaction message
			let transactionMessageHash = new Uint8Array(sha256.arrayBuffer(transactionMessage));
			
			// Get the expected MQS transaction signature from the transaction message hash and MQS private key
			let expectedMqsTransactionSignature = Secp256k1Zkp.createMessageHashSignature(transactionMessageHash, mqsPrivateKey);
			
			// Get the MQS transaction signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(mqsSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS transaction signature
			console.log("MQS transaction signature with MQS sender address: " + Common.toHexString(response));
			
			// Check if MQS transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedMqsTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid MQS transaction signature: " + Common.toHexString(response);
			}
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor sender address from the Tor public key
			let torSenderAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Get transaction message from amount, commitment, and Tor sender address
			transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, torSenderAddress);
			
			// Get transaction message hash from the transaction message
			transactionMessageHash = new Uint8Array(sha256.arrayBuffer(transactionMessage));
			
			// Get the expected MQS transaction signature from the transaction message hash and MQS private key
			expectedMqsTransactionSignature = Secp256k1Zkp.createMessageHashSignature(transactionMessageHash, mqsPrivateKey);
			
			// Get the MQS transaction signature from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(torSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS transaction signature
			console.log("MQS transaction signature with Tor sender address: " + Common.toHexString(response));
			
			// Check if MQS transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedMqsTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid MQS transaction signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting MQS transaction signature test");	
		}
		
		// Encrypt MQS data test
		async function encryptMqsDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running encrypt MQS data test");
			
			// Data
			const DATA = crypto.getRandomValues(new Uint8Array(Math.round(Math.random() * Common.BYTE_MAX_VALUE)));
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// Log data
			console.log("Using data: " + Common.toHexString(DATA));
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get public key from the private key
			let publicKey = Secp256k1Zkp.publicKeyFromSecretKey(privateKey);
			
			// Start encrypting MQS data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(publicKey)
			]));
			
			// Get salt from response
			let salt = response.subarray(0, Mqs.SALT_LENGTH);
			
			// Get nonce from response
			let nonce = response.subarray(Mqs.SALT_LENGTH, Mqs.SALT_LENGTH + Mqs.NONCE_LENGTH);
			
			// Go through all chunks of the data
			let encryptedData = new Uint8Array([]);
			for(let i = 0; i <= DATA["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue encrypting MQS data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(DATA.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append encrypted data to list
				encryptedData = Common.mergeArrays([encryptedData, response]);
			}
			
			// Finish encrypting MQS data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Append tag to encrypted data
			encryptedData = Common.mergeArrays([encryptedData, response]);
			
			// Log encrypted MQS data
			console.log("Encrypted MQS data: " + Common.toHexString(encryptedData));
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Decrypt the encrypted data
			let decryptedData = await Mqs.decryptMessage(privateKey, mqsPublicKey, encryptedData, salt, nonce);
			
			// Log decrypted MQS data
			console.log("Decrypted MQS data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted MQS data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running encrypt MQS data test");
		}
		
		// Decrypt MQS data test
		async function decryptMqsDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running decrypt MQS data test");
			
			// Data
			const DATA = crypto.getRandomValues(new Uint8Array(Math.round(Math.random() * Common.BYTE_MAX_VALUE)));
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// AES IV size
			const AES_IV_SIZE = 16;
			
			// Log data
			console.log("Using data: " + Common.toHexString(DATA));
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get public key from the private key
			let publicKey = Secp256k1Zkp.publicKeyFromSecretKey(privateKey);
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Encrypt the data
			let encryptedData = await Mqs.encryptMessage(privateKey, mqsPublicKey, DATA);
			
			// Get salt from encrypted data
			let salt = encryptedData[Mqs.ENCRYPTED_MESSAGE_SALT_INDEX];
			
			// Get nonce from encrypted data
			let nonce = encryptedData[Mqs.ENCRYPTED_MESSAGE_NONCE_INDEX];
			
			// Get encrypted message from encrypted data
			let encryptedMessage = encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX];
			
			// Log encrypted MQS data
			console.log("Encrypted MQS data: " + Common.toHexString(encryptedMessage));
			
			// Remove tag from the encrypted message
			let tag = encryptedMessage.subarray(encryptedMessage["length"] - Mqs.TAG_LENGTH);
			encryptedMessage = encryptedMessage.subarray(0, encryptedMessage["length"] - Mqs.TAG_LENGTH);
			
			// Start decrypting MQS data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(publicKey),
				
				// Salt
				Buffer.from(salt),
				
				// Nonce
				Buffer.from(nonce),
			]));
			
			// Go through all chunks of the encrypted message
			let decryptedDataChunks = [];
			for(let i = 0; i <= encryptedMessage["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue decrypting MQS data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(encryptedMessage.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append decrypted data chunk to list
				decryptedDataChunks.push(response);
			}
			
			// Finish decrypting MQS data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(tag));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Create AES key from response
			let aesKey = await crypto["subtle"].importKey("raw", response, {"name": "AES-CBC"}, false, ["decrypt"]);
			
			// Go through all decrypted data chunks
			let decryptedData = new Uint8Array([]);
			for(let i = 0; i < decryptedDataChunks["length"]; ++i) {
			
				// Decrypt the data chunk with the AES key
				let data = new Uint8Array(await crypto["subtle"].decrypt({"name": "AES-CBC", "iv": new Uint8Array(AES_IV_SIZE)}, aesKey, decryptedDataChunks[i]));
				
				// Append decrypted data chunk to list
				decryptedData = Common.mergeArrays([decryptedData, data]);
			}
			
			// Log decrypted MQS data
			console.log("Decrypted MQS data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted MQS data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running decrypt MQS data test");
		}
		
		// Receive transaction test
		async function receiveTransactionTest(hardwareWallet, extendedPrivateKey, switchType, features, lockHeight, relativeHeight) {
		
			// Log message
			console.log("Running receive transaction test");
		
			// Output
			const OUTPUT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Input
			const INPUT = new BigNumber(0);
			
			// Fee
			const FEE = new BigNumber((features === SlateKernel.COINBASE_FEATURES) ? 0 : Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Identifier
			const IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Address type
			const ADDRESS_TYPE = TOR_SENDER_ADDRESS_TYPE;
			
			// Log output
			console.log("Using output: " + OUTPUT.toFixed());
			
			// Log identifier
			console.log("Using identifier: " + Common.toHexString(IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Check features
			switch(features) {
			
				// Coinbase features
				case SlateKernel.COINBASE_FEATURES:
				
					// Log features
					console.log("Using features: coinbase");
				
					// Break
					break;
				
				// Plain features
				case SlateKernel.PLAIN_FEATURES:
				
					// Log features
					console.log("Using features: plain");
					
					// Log fee
					console.log("Using fee: " + FEE.toFixed());
				
					// Break
					break;
				
				// Height locked features
				case SlateKernel.HEIGHT_LOCKED_FEATURES:
				
					// Log features
					console.log("Using features: height locked");
					
					// Log fee
					console.log("Using fee: " + FEE.toFixed());
					
					// Log lock height
					console.log("Using lock height: " + lockHeight.toFixed());
				
					// Break
					break;
				
				// No recent duplicate features
				case SlateKernel.NO_RECENT_DUPLICATE_FEATURES:
				
					// Log features
					console.log("Using features: no recent duplicate");
					
					// Log fee
					console.log("Using fee: " + FEE.toFixed());
					
					// Log relative height
					console.log("Using lock height: " + relativeHeight.toFixed());
				
					// Break
					break;
			}
			
			// Get the output's blinding factor
			let outputBlindingFactor = await Crypto.deriveSecretKey(extendedPrivateKey, OUTPUT, IDENTIFIER, switchType);
			
			// Get the sum of all the transaction's blinding factors
			let transactionBlindingFactor = Secp256k1Zkp.blindSum([outputBlindingFactor], []);
			
			// Get the expected transaction public key from the transaction's blinding factor
			let expectedTransactionPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(transactionBlindingFactor);
		
			// Start transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_TRANSACTION_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Output
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Input
				Buffer.from(INPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Fee
				Buffer.from(FEE.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64))
			]));
			
			// Include output in the transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([switchType]))
			]));
			
			// Get the transaction public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
		
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction public key
			console.log("Transaction public key: " + Common.toHexString(response));
			
			// Check if transaction public key is invalid
			if(Common.arraysAreEqual(response, expectedTransactionPublicKey) === false) {
			
				// Throw error
				throw "Invalid transaction public key: " + Common.toHexString(response);
			}
			
			// Create secret nonce
			let secretNonce = Secp256k1Zkp.createSecretNonce();
			
			// Check if features is coinbase
			if(features === SlateKernel.COINBASE_FEATURES) {
				
				// Get public nonce from secret nonce
				var publicNonce = Secp256k1Zkp.publicKeyFromSecretKey(secretNonce);
				
				// Get excess from commit and over commit
				let excess = Secp256k1Zkp.pedersenCommitSum([
				
					// Commit
					await Crypto.commit(extendedPrivateKey, OUTPUT, IDENTIFIER, switchType)
				], [
				
					// Over commit
					Crypto.commitAmount(OUTPUT)
				]);
				
				// Get public key from excess
				var publicKey = Secp256k1Zkp.pedersenCommitToPublicKey(excess);
			}
			
			// Otherwise
			else {
			
				// Get public nonce from secret nonce
				var publicNonce = Secp256k1Zkp.combinePublicKeys([Secp256k1Zkp.publicKeyFromSecretKey(secretNonce)]);
				
				// Get public key from transaction public key
				var publicKey = Secp256k1Zkp.combinePublicKeys([expectedTransactionPublicKey]);
			}
			
			// Check features
			switch(features) {
			
				// Coinbase or plain features
				case SlateKernel.COINBASE_FEATURES:
				case SlateKernel.PLAIN_FEATURES:
				
					// Set kernel information to features
					var kernelInformation = new Uint8Array([features]);
				
					// Break
					break;
				
				// Height locked features
				case SlateKernel.HEIGHT_LOCKED_FEATURES:
				
					// Set kernel information to features followed by the lock height
					var kernelInformation = Common.mergeArrays([
					
						// Features
						new Uint8Array([features]),
						
						// Lock height
						new Uint8Array(lockHeight.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64))
					]);
				
					// Break
					break;
				
				// No recent duplicate features
				case SlateKernel.NO_RECENT_DUPLICATE_FEATURES:
				
					// Set kernel features to features followed by the relative height
					var kernelInformation = Common.mergeArrays([
					
						// Features
						new Uint8Array([features]),
						
						// Relative height
						new Uint8Array(relativeHeight.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64))
					]);
				
					// Break
					break;
			}
			
			// Get signature for the transaction from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_TRANSACTION_INSTRUCTION, ADDRESS_TYPE, NO_PARAMETER, Buffer.concat([
			
				// Secret nonce
				Buffer.from(secretNonce),
				
				// Public nonce
				Buffer.from(publicNonce),
				
				// Public key
				Buffer.from(publicKey),
				
				// Kernel information
				Buffer.from(kernelInformation),
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction signature
			console.log("Transaction signature: " + Common.toHexString(response));
			
			// Get message to sign
			let messageToSign = SlateKernel.signatureMessage(features, FEE, lockHeight, relativeHeight);
			
			// Check if signature is invalid
			if(Secp256k1Zkp.verifySingleSignerSignature(response, messageToSign, publicNonce, publicKey, publicKey, false) === false) {
			
				// Throw error
				throw "Invalid signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed running receive transaction test");
		}
		
		// Send transaction test
		async function sendTransactionTest(hardwareWallet, extendedPrivateKey, switchType, features, lockHeight, relativeHeight, senderAddressType, paymentProofType) {
		
			// Log message
			console.log("Running send transaction test");
		
			// Output
			const OUTPUT = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Fee
			const FEE = new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
			
			// Input
			const INPUT = (new BigNumber(Math.round(Math.random() * Number.MAX_SAFE_INTEGER))).plus(OUTPUT);
			
			// Output identifier
			const OUTPUT_IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Input identifier
			const INPUT_IDENTIFIER = new Identifier(Common.toHexString(Common.mergeArrays([new Uint8Array([Math.round(Math.random() * Identifier.MAX_DEPTH)]), crypto.getRandomValues(new Uint8Array(Identifier.MAX_DEPTH * Uint32Array["BYTES_PER_ELEMENT"]))])));
			
			// Input switch type
			const INPUT_SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Log output
			console.log("Using output: " + OUTPUT.toFixed());
			
			// Log input
			console.log("Using input: " + INPUT.toFixed());
			
			// Log fee
			console.log("Using fee: " + FEE.toFixed());
			
			// Log output identifier
			console.log("Using output identifier: " + Common.toHexString(OUTPUT_IDENTIFIER.getValue()));
			
			// Log input identifier
			console.log("Using input identifier: " + Common.toHexString(INPUT_IDENTIFIER.getValue()));
			
			// Check switch type
			switch(switchType) {
			
				// Switch type none
				case Crypto.SWITCH_TYPE_NONE:
				
					// Log switch type
					console.log("Using switch type: none");
				
					// Break
					break;
				
				// Regular switch type
				case Crypto.SWITCH_TYPE_REGULAR:
				
					// Log switch type
					console.log("Using switch type: regular");
				
					// Break
					break;
			}
			
			// Check features
			switch(features) {
			
				// Coinbase features
				case SlateKernel.COINBASE_FEATURES:
				
					// Log features
					console.log("Using features: coinbase");
				
					// Break
					break;
				
				// Plain features
				case SlateKernel.PLAIN_FEATURES:
				
					// Log features
					console.log("Using features: plain");
				
					// Break
					break;
				
				// Height locked features
				case SlateKernel.HEIGHT_LOCKED_FEATURES:
				
					// Log features
					console.log("Using features: height locked");
					
					// Log lock height
					console.log("Using lock height: " + lockHeight.toFixed());
				
					// Break
					break;
				
				// No recent duplicate features
				case SlateKernel.NO_RECENT_DUPLICATE_FEATURES:
				
					// Log features
					console.log("Using features: no recent duplicate");
					
					// Log relative height
					console.log("Using lock height: " + relativeHeight.toFixed());
				
					// Break
					break;
			}
			
			// Check sender address type
			switch(senderAddressType) {
			
				// Tor sender address type
				case TOR_SENDER_ADDRESS_TYPE:
				
					// Log sender address type
					console.log("Using sender address type: Tor");
					
					// Get Tor private key from the extended private key
					let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
					
					// Get Tor public key from the Tor private key
					let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
					
					// Get sender address from the Tor public key
					var senderAddress = Tor.publicKeyToTorAddress(torPublicKey);
				
					// Break
					break;
				
				// MQS sender address type
				case MQS_SENDER_ADDRESS_TYPE:
				
					// Log sender address type
					console.log("Using sender address type: MQS");
					
					// Get MQS private key from the extended private key
					let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
					
					// Get MQS public key from the MQS private key
					let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
					
					// Get sender address from the MQS public key
					var senderAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
				
					// Break
					break;
			}
			
			// Get random commitment
			let commit = await Crypto.commit(extendedPrivateKey, INPUT.minus(OUTPUT), OUTPUT_IDENTIFIER, INPUT_SWITCH_TYPE);
			
			// Set payment proof message
			let paymentProofMessage = Slate.getPaymentProofMessage(INPUT.minus(OUTPUT), commit, senderAddress);
			
			// Check payment proof type
			switch(paymentProofType) {
			
				// No payment proof type
				case NO_PAYMENT_PROOF_TYPE:
				
					// Log payment proof type
					console.log("Using payment proof type: none");
				
					// Break
					break;
				
				// Tor payment proof type
				case TOR_PAYMENT_PROOF_TYPE:
				
					// Log payment proof type
					console.log("Using payment proof type: Tor");
				
					// Get Tor private key from the extended private key
					let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
					
					// Get Tor public key from the Tor private key
					let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
					
					// Get receiver address from the Tor public key
					var receiverAddress = Tor.publicKeyToTorAddress(torPublicKey);
					
					// Set recever signature as the payment proof message signed by the Tor private key
					var receiverSignature = Ed25519.sign(paymentProofMessage, torPrivateKey);
				
					// Break
					break;
				
				// MQS payment proof type
				case MQS_PAYMENT_PROOF_TYPE:
				
					// Log payment proof type
					console.log("Using payment proof type: MQS");
				
					// Get MQS private key from the extended private key
					let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
					
					// Get MQS public key from the MQS private key
					let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
					
					// Get receiver address from the MQS public key
					var receiverAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
					
					// Get payment proof message hash
					let paymentProofMessageHash = new Uint8Array(sha256.arrayBuffer(paymentProofMessage));
					
					// Set recever signature as the payment proof message hash signed by the MQS private key
					var receiverSignature = Secp256k1Zkp.createMessageHashSignature(paymentProofMessageHash, mqsPrivateKey);
					
					// Break
					break;
			}
			
			// Get the output's blinding factor
			let outputBlindingFactor = await Crypto.deriveSecretKey(extendedPrivateKey, OUTPUT, OUTPUT_IDENTIFIER, switchType);
			
			// Get the input's blinding factor
			let inputBlindingFactor = await Crypto.deriveSecretKey(extendedPrivateKey, INPUT.plus(FEE), INPUT_IDENTIFIER, INPUT_SWITCH_TYPE);
			
			// Get the sum of all the transaction's blinding factors
			let transactionBlindingFactor = Secp256k1Zkp.blindSum([outputBlindingFactor], [inputBlindingFactor]);
			
			// Get the expected transaction public key from the transaction's blinding factor
			let expectedTransactionPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(transactionBlindingFactor);
			
			// Start transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_TRANSACTION_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Output
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Input
				Buffer.from(INPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Fee
				Buffer.from(FEE.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Receiver address
				Buffer.from((paymentProofType !== NO_PAYMENT_PROOF_TYPE) ? receiverAddress : [])
			]));
			
			// Include output in the transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Identifier
				Buffer.from(OUTPUT_IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([switchType]))
			]));
			
			// Include input in the transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_INCLUDE_INPUT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Identifier
				Buffer.from(INPUT_IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from((INPUT.plus(FEE)).toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([INPUT_SWITCH_TYPE]))
			]));
			
			// Get the transaction public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction public key before offset
			console.log("Transaction public key before offset: " + Common.toHexString(response));
			
			// Check if transaction public key is invalid
			if(Common.arraysAreEqual(response, expectedTransactionPublicKey) === false) {
			
				// Throw error
				throw "Invalid transaction public key: " + Common.toHexString(response);
			}
			
			// While offset isn't a valid secret key
			let offset = new Uint8Array(Crypto.BLINDING_FACTOR_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(offset);
				
			} while(Secp256k1Zkp.isValidSecretKey(offset) === false);
			
			// Update the transaction blinding factor to include the offset
			transactionBlindingFactor = Secp256k1Zkp.blindSum([transactionBlindingFactor], [offset]);
			
			// Get the expected transaction public key from the transaction's blinding factor
			expectedTransactionPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(transactionBlindingFactor);
			
			// Apply offset to the transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_APPLY_OFFSET_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(offset));
			
			// Get the transaction public key from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction public key after offset
			console.log("Transaction public key after offset: " + Common.toHexString(response));
			
			// Check if transaction public key is invalid
			if(Common.arraysAreEqual(response, expectedTransactionPublicKey) === false) {
			
				// Throw error
				throw "Invalid transaction public key: " + Common.toHexString(response);
			}
			
			// Create secret nonce
			let secretNonce = Secp256k1Zkp.createSecretNonce();
			
			// Get public nonce from secret nonce
			let publicNonce = Secp256k1Zkp.combinePublicKeys([Secp256k1Zkp.publicKeyFromSecretKey(secretNonce)]);
			
			// Get public key from transaction public key
			let publicKey = Secp256k1Zkp.combinePublicKeys([expectedTransactionPublicKey]);
			
			// Check features
			switch(features) {
			
				// Coinbase or plain features
				case SlateKernel.COINBASE_FEATURES:
				case SlateKernel.PLAIN_FEATURES:
				
					// Set kernel information to features
					var kernelInformation = new Uint8Array([features]);
				
					// Break
					break;
				
				// Height locked features
				case SlateKernel.HEIGHT_LOCKED_FEATURES:
				
					// Set kernel information to features followed by the lock height
					var kernelInformation = Common.mergeArrays([
					
						// Features
						new Uint8Array([features]),
						
						// Lock height
						new Uint8Array(lockHeight.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64))
					]);
				
					// Break
					break;
				
				// No recent duplicate features
				case SlateKernel.NO_RECENT_DUPLICATE_FEATURES:
				
					// Set kernel features to features followed by the relative height
					var kernelInformation = Common.mergeArrays([
					
						// Features
						new Uint8Array([features]),
						
						// Relative height
						new Uint8Array(relativeHeight.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64))
					]);
				
					// Break
					break;
			}
			
			// Log message
			console.log("Verify that the transaction's amount is: " + INPUT.minus(OUTPUT).dividedBy(Consensus.VALUE_NUMBER_BASE).toFixed() + " " + Consensus.CURRENCY_NAME);
			
			// Log message
			console.log("Verify that the transaction's fee is: " + FEE.dividedBy(Consensus.VALUE_NUMBER_BASE).toFixed() + " " + Consensus.CURRENCY_NAME);
			
			// Initialize payment proof information
			let paymentProofInformation = [];
			
			// Check if using a payment proof
			if(paymentProofType !== NO_PAYMENT_PROOF_TYPE) {
			
				// Set payment proof information
				paymentProofInformation = Buffer.concat([
				
					// Commit
					Buffer.from(commit),
					
					// Receiver signature
					Buffer.from(receiverSignature)
				]);
				
				// Log message
				console.log("Verify that the transaction's receive address is: " + receiverAddress);
			}
			
			// Otherwise
			else {
			
				// Log message
				console.log("Verify that the transaction contains no payment proof");
			}
			
			// Get signature for the transaction from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_TRANSACTION_INSTRUCTION, senderAddressType, NO_PARAMETER, Buffer.concat([
			
				// Secret nonce
				Buffer.from(secretNonce),
				
				// Public nonce
				Buffer.from(publicNonce),
				
				// Public key
				Buffer.from(publicKey),
				
				// Kernel information
				Buffer.from(kernelInformation),
				
				// Payment proof information
				Buffer.from(paymentProofInformation)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction signature
			console.log("Transaction signature: " + Common.toHexString(response));
			
			// Get message to sign
			let messageToSign = SlateKernel.signatureMessage(features, FEE, lockHeight, relativeHeight);
			
			// Check if signature is invalid
			if(Secp256k1Zkp.verifySingleSignerSignature(response, messageToSign, publicNonce, publicKey, publicKey, false) === false) {
			
				// Throw error
				throw "Invalid signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed running send transaction test");
		}
		
		// Find text delimiter
		function findTextDelimiter(text) {
		
			// Return finding text delimiter in the text
			return text.findIndex(function(element, index, array) {
			
				// Return if the element is a text delimiter
				return element === TEXT_DELIMITER;
			});
		}
	</script>
</head>
<body>
	<p>Open browser's console and click the run button to perform tests</p>
	<form>
		<p>Choose hardware wallet transport method:</p>
		<div>
			<input type="radio" id="transportMethodUsb" name="transportMethod" value="USB" checked>
			<label for="transportMethodUsb">USB</label>

			<input type="radio" id="transportMethodBluetooth" name="transportMethod" value="Bluetooth">
			<label for="transportMethodBluetooth">Bluetooth</label>
			
			<input type="radio" id="transportMethodHttp" name="transportMethod" value="HTTP">
			<label for="transportMethodHttp">HTTP</label>
		</div>
		<div>
			<button type="submit" disabled>Loadingâ€¦</button>
		</div>
	</form>
</body>
</html>
