"use strict";class NewProofBuilder extends ProofBuilder{initialize(e){var r=this;return new Promise((function(t,i){return Crypto.deriveSecretKey(e,new BigNumber(0),new Identifier(Identifier.ROOT_SERIALIZED_IDENTIFIER),Crypto.SWITCH_TYPE_NONE).then((function(E){if(r.privateHash=Blake2b.compute(Crypto.NONCE_LENGTH,E,new Uint8Array([])),r.privateHash!==Blake2b.OPERATION_FAILED)return E.fill(0),Crypto.rootPublicKey(e).then((function(e){r.rewindHash=Blake2b.compute(Crypto.NONCE_LENGTH,e,new Uint8Array([])),r.rewindHash!==Blake2b.OPERATION_FAILED?(e.fill(0),t()):(r.privateHash.fill(0),e.fill(0),i("Getting Rewind hash failed."))})).catch((function(e){r.privateHash.fill(0),i(e)}));E.fill(0),i("Getting private hash failed.")})).catch((function(e){i(e)}))}))}uninitialize(){this.privateHash.fill(0),this.rewindHash.fill(0)}rewindNonce(e){var r=this;return new Promise((function(t,i){var E=Blake2b.compute(Crypto.NONCE_LENGTH,r.rewindHash,e);E!==Blake2b.OPERATION_FAILED?!0===Secp256k1Zkp.isValidSecretKey(E)?t(E):(E.fill(0),i("Nonce is not a valid secret key.")):i("Getting nonce failed.")}))}privateNonce(e){var r=this;return new Promise((function(t,i){var E=Blake2b.compute(Crypto.NONCE_LENGTH,r.privateHash,e);E!==Blake2b.OPERATION_FAILED?!0===Secp256k1Zkp.isValidSecretKey(E)?t(E):(E.fill(0),i("Nonce is not a valid secret key.")):i("Getting nonce failed.")}))}proofMessage(e,r){var t=new Uint8Array(NewProofBuilder.MESSAGE_LENGTH).fill(0);return t[NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX]=r,t=Common.mergeArrays([t.subarray(0,NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1),e.getValue().subarray(0,NewProofBuilder.MESSAGE_LENGTH-(NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1))])}getOutput(e,r,t,i){return new Promise((function(E,n){if(i.length===NewProofBuilder.MESSAGE_LENGTH&&!0===Common.arraysAreEqual(i.subarray(0,NewProofBuilder.MESSAGE_HEADER_START.length),NewProofBuilder.MESSAGE_HEADER_START)){var o=i[NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX];if(o===Crypto.SWITCH_TYPE_NONE||o===Crypto.SWITCH_TYPE_REGULAR){var a=Math.min(i[NewProofBuilder.MESSAGE_DEPTH_INDEX],Identifier.MAX_DEPTH);try{var l=new Identifier(a.toString(Common.HEX_NUMBER_BASE).padStart(Common.HEX_NUMBER_LENGTH,Common.HEX_NUMBER_PADDING)+Common.toHexString(i.subarray(NewProofBuilder.MESSAGE_HEADER_LENGTH)))}catch(e){return void n("Identifier isn't valid.")}return Crypto.commit(e,r,l,o).then((function(e){!0===Common.arraysAreEqual(t,e)?E([l,o]):n("Output isn't valid.")})).catch((function(e){n(e)}))}n("Switch type isn't valid.")}else n("Message isn't valid.")}))}static get MESSAGE_HEADER_START(){return new Uint8Array([0,0])}static get MESSAGE_SWITCH_TYPE_INDEX(){return NewProofBuilder.MESSAGE_HEADER_START.length}static get MESSAGE_DEPTH_INDEX(){return NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1}static get MESSAGE_HEADER_LENGTH(){return NewProofBuilder.MESSAGE_DEPTH_INDEX+1}static get MESSAGE_LENGTH(){return NewProofBuilder.MESSAGE_HEADER_LENGTH+Identifier.MAX_DEPTH*Uint32Array.BYTES_PER_ELEMENT}}