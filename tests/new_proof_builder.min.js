"use strict";class NewProofBuilder extends ProofBuilder{initialize(e){var r=this;return new Promise((function(E,t){return Crypto.deriveSecretKey(e,new BigNumber(0),new Identifier(Identifier.ROOT_SERIALIZED_IDENTIFIER),Crypto.SWITCH_TYPE_NONE).then((function(i){if(r.privateHash=Blake2b.compute(Crypto.SECP256K1_SECRET_KEY_LENGTH,i,new Uint8Array([])),r.privateHash!==Blake2b.OPERATION_FAILED)return i.fill(0),Crypto.rootPublicKey(e).then((function(e){r.rewindHash=Blake2b.compute(Crypto.SECP256K1_SECRET_KEY_LENGTH,e,new Uint8Array([])),r.rewindHash!==Blake2b.OPERATION_FAILED?(e.fill(0),E()):(r.privateHash.fill(0),e.fill(0),t("Getting Rewind hash failed."))})).catch((function(e){r.privateHash.fill(0),t(e)}));i.fill(0),t("Getting private hash failed.")})).catch((function(e){t(e)}))}))}uninitialize(){this.privateHash.fill(0),this.rewindHash.fill(0)}rewindNonce(e){var r=this;return new Promise((function(E,t){var i=Blake2b.compute(Crypto.SECP256K1_SECRET_KEY_LENGTH,r.rewindHash,e);i!==Blake2b.OPERATION_FAILED?!0===Secp256k1Zkp.isValidSecretKey(i)?E(i):t("Nonce is not a valid secret key."):t("Getting nonce failed.")}))}privateNonce(e){var r=this;return new Promise((function(E,t){var i=Blake2b.compute(Crypto.SECP256K1_SECRET_KEY_LENGTH,r.privateHash,e);i!==Blake2b.OPERATION_FAILED?!0===Secp256k1Zkp.isValidSecretKey(i)?E(i):t("Nonce is not a valid secret key."):t("Getting nonce failed.")}))}proofMessage(e,r){var E=new Uint8Array(NewProofBuilder.MESSAGE_LENGTH).fill(0);return E[NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX]=r,E=Common.mergeArrays([E.subarray(0,NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1),e.getValue().subarray(0,NewProofBuilder.MESSAGE_LENGTH-(NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1))])}getOutput(e,r,E,t){return new Promise((function(i,n){if(t.length===NewProofBuilder.MESSAGE_LENGTH&&!0===Common.arraysAreEqual(t.subarray(0,NewProofBuilder.MESSAGE_HEADER_START.length),NewProofBuilder.MESSAGE_HEADER_START)){var o=t[NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX];if(o===Crypto.SWITCH_TYPE_NONE||o===Crypto.SWITCH_TYPE_REGULAR){var a=Math.min(t[NewProofBuilder.MESSAGE_DEPTH_INDEX],Identifier.MAX_DEPTH);try{var _=new Identifier(a.toString(Common.HEX_NUMBER_BASE).padStart(Common.HEX_NUMBER_LENGTH,Common.HEX_NUMBER_PADDING)+Common.toHexString(t.subarray(NewProofBuilder.MESSAGE_HEADER_LENGTH)))}catch(e){return void n("Identifier isn't valid.")}return Crypto.commit(e,r,_,o).then((function(e){!0===Common.arraysAreEqual(E,e)?i([_,o]):n("Output isn't valid.")})).catch((function(e){n(e)}))}n("Switch type isn't valid.")}else n("Message isn't valid.")}))}static get MESSAGE_HEADER_START(){return new Uint8Array([0,0])}static get MESSAGE_SWITCH_TYPE_INDEX(){return NewProofBuilder.MESSAGE_HEADER_START.length}static get MESSAGE_DEPTH_INDEX(){return NewProofBuilder.MESSAGE_SWITCH_TYPE_INDEX+1}static get MESSAGE_HEADER_LENGTH(){return NewProofBuilder.MESSAGE_DEPTH_INDEX+1}static get MESSAGE_LENGTH(){return NewProofBuilder.MESSAGE_HEADER_LENGTH+Identifier.MAX_DEPTH*Uint32Array.BYTES_PER_ELEMENT}}