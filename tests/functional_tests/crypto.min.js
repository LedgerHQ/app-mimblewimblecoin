"use strict";const crypto=require("crypto"),Blake2b=require("./BLAKE2b.min.js"),Secp256k1Zkp=require("./secp256k1-zkp.min.js"),BigNumber=require("./bignumber.js-9.0.2.min.js"),Common=require("./common.min.js"),Identifier=require("./identifier.min.js");class Crypto{static deriveChildKey(e,t){return new Promise((function(r,i){var n=e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),c=e.subarray(Crypto.CHAIN_CODE_LENGTH),E=new Promise((function(e,t){e([new Uint8Array(n),new Uint8Array(c)])})),a=[E];for(let e=0;e<t.length;++e)E=E.then((function(r){return new Promise((function(i,n){var c=r[Crypto.SECRET_KEY_INDEX],E=r[Crypto.CHAIN_CODE_INDEX];return Crypto.deriveSecretKeyAndChainCode(c,E,t[e]).then((function(e){c.fill(0),E.fill(0),i(e)})).catch((function(e){c.fill(0),E.fill(0),n(e)}))}))})).catch((function(e){return new Promise((function(t,r){r(e)}))})),a.push(E);return Promise.all(a).then((function(e){var t=e[e.length-1][Crypto.SECRET_KEY_INDEX],n=e[e.length-1][Crypto.CHAIN_CODE_INDEX],c=Common.mergeArrays([t,n]);t.fill(0),n.fill(0),!0===Secp256k1Zkp.isValidSecretKey(c.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH))?r(c):(c.fill(0),i("Invalid extended private key."))})).catch((function(e){i(e)}))}))}static commit(e,t,r,i){return new Promise((function(n,c){return Crypto.deriveSecretKey(e,t,r,i).then((function(e){var r=Secp256k1Zkp.pedersenCommit(e,t.toFixed());r!==Secp256k1Zkp.OPERATION_FAILED?n(r):(e.fill(0),c("Performing Pedersen commit failed."))})).catch((function(e){c(e)}))}))}static commitAmount(e){var t=Secp256k1Zkp.pedersenCommit(Crypto.ZERO_BLINDING_FACTOR,e.toFixed());if(t!==Secp256k1Zkp.OPERATION_FAILED)return t;throw"Performing Pedersen commit failed."}static proof(e,t,r,i,n){return new Promise((function(c,E){return Crypto.commit(e,t,r,i).then((function(a){return Crypto.deriveSecretKey(e,t,r,i).then((function(e){return n.rewindNonce(a).then((function(o){return n.privateNonce(a).then((function(a){try{var _=n.proofMessage(r,i)}catch(t){return e.fill(0),o.fill(0),a.fill(0),void E("Getting proof message failed.")}var u=Secp256k1Zkp.createBulletproof(e,t.toFixed(),o,a,new Uint8Array([]),_);u!==Secp256k1Zkp.OPERATION_FAILED?(e.fill(0),o.fill(0),a.fill(0),c(u)):(e.fill(0),o.fill(0),a.fill(0),E("Getting bulletproof failed."))})).catch((function(t){e.fill(0),o.fill(0),E(t)}))})).catch((function(t){e.fill(0),E(t)}))})).catch((function(e){E(e)}))})).catch((function(e){E(e)}))}))}static deriveSecretKey(e,t,r,i){return new Promise((function(n,c){for(var E=new Uint32Array(r.getDepth()),a=0;a<r.getDepth();++a)E[a]=r.getPaths()[a];return Crypto.deriveChildKey(e,E).then((function(e){var r=new Uint8Array(e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH));if(e.fill(0),i===Crypto.SWITCH_TYPE_NONE)n(r);else if(i===Crypto.SWITCH_TYPE_REGULAR){var E=Secp256k1Zkp.blindSwitch(r,t.toFixed());if(E===Secp256k1Zkp.OPERATION_FAILED)return r.fill(0),void c("Performing blind switch failed.");r.fill(0),!0===Secp256k1Zkp.isValidSecretKey(E)?n(E):(E.fill(0),c("Blind switch isn't a valid secret key."))}else r.fill(0),c("Invalid switch type.")})).catch((function(e){c(e)}))}))}static signatureMessage(e){var t=Blake2b.compute(Crypto.SINGLE_SIGNER_MESSAGE_LENGTH,e,new Uint8Array([]));if(t!==Blake2b.OPERATION_FAILED)return t;throw"Creating signature message failed."}static rootPublicKey(e){return new Promise((function(t,r){var i=e.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),n=Secp256k1Zkp.publicKeyFromSecretKey(i);n!==Secp256k1Zkp.OPERATION_FAILED?t(n):r("Getting public key failed.")}))}static addressKey(e,t){return new Promise((function(r,i){return Crypto.deriveSecretKey(e,Crypto.ADDRESS_KEY_AMOUNT,new Identifier(Identifier.ROOT_SERIALIZED_IDENTIFIER),Crypto.SWITCH_TYPE_REGULAR).then((function(e){return crypto.subtle.importKey("raw",(new TextEncoder).encode(Crypto.ADDRESS_KEY_SEED),{name:Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,hash:{name:Crypto.ADDRESS_KEY_DIGEST_ALGORITHM}},!1,["sign"]).then((function(n){return crypto.subtle.sign(Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,n,e).then((function(n){e.fill(0);var c=(n=new Uint8Array(n)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),E=n.subarray(Crypto.CHAIN_CODE_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(c))return Crypto.deriveSecretKeyAndChainCode(c,E,t).then((function(e){n.fill(0),e[Crypto.CHAIN_CODE_INDEX].fill(0),r(e[Crypto.SECRET_KEY_INDEX])})).catch((function(e){n.fill(0),i(e)}));n.fill(0),i("Secret key is not a valid secret key.")})).catch((function(t){e.fill(0),i(t)}))})).catch((function(t){e.fill(0),i(t)}))})).catch((function(e){i(e)}))}))}static aesDecrypt(e,t){return new Promise((function(r,i){return crypto.subtle.importKey("raw",t,{name:Crypto.AES_ALGORITHM},!1,["decrypt"]).then((function(t){return crypto.subtle.decrypt({name:Crypto.AES_ALGORITHM,iv:new Uint8Array(Crypto.AES_INITIALIZATION_VECTOR_SIZE).fill(0)},t,e).then((function(e){r(new Uint8Array(e))})).catch((function(e){i(e)}))})).catch((function(e){i(e)}))}))}static get SWITCH_TYPE_NONE(){return 0}static get SWITCH_TYPE_REGULAR(){return Crypto.SWITCH_TYPE_NONE+1}static get SECP256K1_SECRET_KEY_LENGTH(){return 32}static get SECP256K1_PUBLIC_KEY_LENGTH(){return 33}static get BLINDING_FACTOR_LENGTH(){return 32}static get COMMIT_LENGTH(){return 33}static get SINGLE_SIGNER_SIGNATURE_LENGTH(){return 64}static get SINGLE_SIGNER_MESSAGE_LENGTH(){return 32}static get MAXIMUM_PROOF_LENGTH(){return 5134}static get ZERO_BLINDING_FACTOR(){return new Uint8Array(Crypto.BLINDING_FACTOR_LENGTH).fill(0)}static get ED25519_PUBLIC_KEY_LENGTH(){return 32}static get ED25519_SIGNATURE_LENGTH(){return 64}static get MAXIMUM_MESSAGE_HASH_SIGNATURE_LENGTH(){return 72}static get NONCE_LENGTH(){return 32}static get TAU_X_LENGTH(){return 32}static get AES_KEY_LENGTH(){return 32}static deriveSecretKeyAndChainCode(e,t,r){return new Promise((function(i,n){return crypto.subtle.importKey("raw",t,{name:Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,hash:{name:Crypto.CHAIN_CODE_DIGEST_ALGORITHM}},!1,["sign"]).then((function(t){if(!0===Identifier.isPathHardened(r))var c=Common.mergeArrays([new Uint8Array([0]),e]);else if((c=Secp256k1Zkp.publicKeyFromSecretKey(e))===Secp256k1Zkp.OPERATION_FAILED)return void n("Getting public key from secret key failed.");var E=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT);new DataView(E).setUint32(0,r,!1);var a=Common.mergeArrays([c,new Uint8Array(E)]);return c.fill(0),crypto.subtle.sign(Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,t,a).then((function(t){a.fill(0);var r=(t=new Uint8Array(t)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(r)){var c=Secp256k1Zkp.secretKeyTweakAdd(r,e);if(c===Secp256k1Zkp.OPERATION_FAILED)return t.fill(0),void n("Performing secret key tweak add failed.");if(!0===Secp256k1Zkp.isValidSecretKey(c)){var E=new Uint8Array(t.subarray(Crypto.CHAIN_CODE_LENGTH));t.fill(0),i([c,E])}else t.fill(0),c.fill(0),n("Updated secret key is not a valid secret key.")}else t.fill(0),n("New secret key is not a valid secret key.")})).catch((function(e){a.fill(0),n("Creating new extended private key failed.")}))})).catch((function(e){n("Creating crypto key failed.")}))}))}static get CHAIN_CODE_LENGTH(){return 32}static get SECRET_KEY_INDEX(){return 0}static get CHAIN_CODE_INDEX(){return Crypto.SECRET_KEY_INDEX+1}static get CHAIN_CODE_ENCRYPTION_ALGORITHM(){return"HMAC"}static get CHAIN_CODE_DIGEST_ALGORITHM(){return"SHA-512"}static get ADDRESS_KEY_AMOUNT(){return new BigNumber(713)}static get ADDRESS_KEY_SEED(){return"Grinbox_seed"}static get ADDRESS_KEY_ENCRYPTION_ALGORITHM(){return"HMAC"}static get ADDRESS_KEY_DIGEST_ALGORITHM(){return"SHA-512"}static get AES_ALGORITHM(){return"AES-CBC"}static get AES_INITIALIZATION_VECTOR_SIZE(){return 16}}module.exports=Crypto;