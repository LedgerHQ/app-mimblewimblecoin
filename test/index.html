<!DOCTYPE html>
<html>

<head>

	<meta charset="UTF-8">

	<script src="BLAKE2b.min.js"></script>
	<script src="Ed25519.min.js"></script>
	<script src="X25519.min.js"></script>
	<script src="LedgerJS-6.10.0.min.js"></script>
	<script src="secp256k1-zkp.min.js"></script>
	<script src="bignumber.js-9.0.1.min.js"></script>
	<script src="js-sha3-0.8.0.min.js"></script>
	<script src="js-sha256-0.9.0.min.js"></script>
	<script src="hi-base32-0.5.1.min.js"></script>
	<script src="ChaCha-2.1.0.min.js"></script>
	<script src="common.min.js"></script>
	<script src="identifier.min.js"></script>
	<script src="crypto.min.js"></script>
	<script src="seed.min.js"></script>
	<script src="tor.min.js"></script>
	<script src="mqs.min.js"></script>
	<script src="slatepack.min.js"></script>
	<script src="consensus.min.js"></script>
	<script src="base58.min.js"></script>
	<script src="proof_builder.min.js"></script>
	<script src="new_proof_builder.min.js"></script>
	<script src="slate.min.js"></script>
	
	<script>
	
		// Constants
		
		// Request class
		const REQUEST_CLASS = 0xC7;
		
		// Request get application information instruction
		const REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION = 0;

		// Request get root public key instruction
		const REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION = REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION + 1;

		// Request get public key verification instruction
		const REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION = REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION + 1;

		// Request get seed cookie instruction
		const REQUEST_GET_SEED_COOKIE_INSTRUCTION = REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION + 1;

		// Request get commitment instruction
		const REQUEST_GET_COMMITMENT_INSTRUCTION = REQUEST_GET_SEED_COOKIE_INSTRUCTION + 1;

		// Request get bulletproof tau x instruction
		const REQUEST_GET_BULLETPROOF_TAU_X_INSTRUCTION = REQUEST_GET_COMMITMENT_INSTRUCTION + 1;

		// Request get bulletproof t one and t two instruction
		const REQUEST_GET_BULLETPROOF_T_ONE_AND_T_TWO_INSTRUCTION = REQUEST_GET_BULLETPROOF_TAU_X_INSTRUCTION + 1;

		// Request get Tor public key instruction
		const REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION = REQUEST_GET_BULLETPROOF_T_ONE_AND_T_TWO_INSTRUCTION + 1;

		// Request get Tor transaction signature instruction
		const REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION = REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION + 1;

		// Request get Tor certificate signature instruction
		const REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION = REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION + 1;

		// Request start encrypting Slatepack data instruction
		const REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION + 1;

		// Request continue encrypting Slatepack data instruction
		const REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request finish encrypting Slatepack data instruction
		const REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request start decrypting Slatepack data instruction
		const REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request continue decrypting Slatepack data instruction
		const REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request finish decrypting Slatepack data instruction
		const REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION = REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request get MQS public key instruction
		const REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION = REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION + 1;

		// Request get MQS transaction signature instruction
		const REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION = REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION + 1;

		// Request start encrypting MQS data instruction
		const REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION + 1;

		// Request continue encrypting MQS data instruction
		const REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request finish encrypting MQS data instruction
		const REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION = REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request start decrypting MQS data instruction
		const REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request continue decrypting MQS data instruction
		const REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request finish decrypting MQS data instruction
		const REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION = REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request start transaction instruction
		const REQUEST_START_TRANSACTION_INSTRUCTION = REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION + 1;

		// Request continue transaction include output instruction
		const REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION = REQUEST_START_TRANSACTION_INSTRUCTION + 1;

		// Request continue transaction include input instruction
		const REQUEST_CONTINUE_TRANSACTION_INCLUDE_INPUT_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION + 1;

		// Request continue transaction apply offset instruction
		const REQUEST_CONTINUE_TRANSACTION_APPLY_OFFSET_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_INCLUDE_INPUT_INSTRUCTION + 1;

		// Request continue transaction get public key instruction
		const REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_APPLY_OFFSET_INSTRUCTION + 1;

		// Request finish transaction instruction
		const REQUEST_FINISH_TRANSACTION_INSTRUCTION = REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION + 1;
		
		// No parameter
		const NO_PARAMETER = 0;
		
		// Text delimiter
		const TEXT_DELIMITER = 0;
		
		// Mnemonic
		const MNEMONIC = "abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon about";
		
		// Seed key
		const SEED_KEY = "IamVoldemort";
		
		// Account
		const ACCOUNT = new BigNumber(0);
		
		// Response delimiter length
		const RESPONSE_DELIMITER_LENGTH = (new Uint8Array([0x00, 0x00]))["length"];
		
		// Tor address key index
		const TOR_ADDRESS_KEY_INDEX = 0;
		
		// MQS address key index
		const MQS_ADDRESS_KEY_INDEX = 0;
		
		
		// Main function
		window.addEventListener("load", async function() {
		
			// Initialize BLAKE2b
			await Blake2b.initialize();
			
			// Initialize Ed25519
			await Ed25519.initialize();
			
			// Initialize X25519
			await X25519.initialize();
			
			// Initialize secp256k1-zkp
			await Secp256k1Zkp.initialize();
			
			// Get button
			let button = document.querySelector("button");
			
			// Button click event
			button.addEventListener("click", async function() {
			
				// Disable button
				button["disabled"] = true;
				
				// Change button's text
				button["textContent"] = "Runningâ€¦";
				
				// Try
				try {
				
					// Connect to the hardware wallet
					let hardwareWallet = await /*TransportWebUSB.create()*/HttpTransport().open("http://localhost:9998");
					
					// Log message
					console.log("Running tests with the mnemonic: " + MNEMONIC);
					
					// Initialize seed
					let seed = new Seed();
					await seed.initialize(MNEMONIC);
					
					// Get the extended private key from the seed
					let extendedPrivateKey = await seed.getExtendedPrivateKey(SEED_KEY);
					
					// Run get application information test
					await getApplicationInformationTest(hardwareWallet);
					
					// Run get root public key test
					await getRootPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get public key verification test
					await getPublicKeyVerificationTest(hardwareWallet, extendedPrivateKey);
					
					// Run get seed cookie test
					await getSeedCookieTest(hardwareWallet, extendedPrivateKey);
					
					// Run get commitment test
					await getCommitmentTest(hardwareWallet, extendedPrivateKey);
					
					// Run get bulletproof test
					await getBulletproofTest(hardwareWallet, extendedPrivateKey);
					
					// Run get Tor public key test
					await getTorPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get Tor transaction signature test
					await getTorTransactionSignatureTest(hardwareWallet, extendedPrivateKey);
					
					// Run get Tor certificate signature test
					await getTorCertificateSignatureTest(hardwareWallet, extendedPrivateKey);
					
					// Run encrypt Slatepack data test
					await encryptSlatepackDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run decrypt Slatepack data test
					await decryptSlatepackDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run get MQS public key test
					await getMqsPublicKeyTest(hardwareWallet, extendedPrivateKey);
					
					// Run get MQS transaction signature test
					await getMqsTransactionSignatureTest(hardwareWallet, extendedPrivateKey);
					
					// Run encrypt MQS data test
					await encryptMqsDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run decrypt MQS data test
					await decryptMqsDataTest(hardwareWallet, extendedPrivateKey);
					
					// Run receive transaction test
					//await receiveTransactionTest(hardwareWallet, extendedPrivateKey);
					
					// Log message
					console.log("Passed running all tests");
				}
				
				// Catch errors
				catch(error) {
				
					// Log error
					console.log(error);
					
					// Log message
					console.log("Running tests failed");
				}
				
				// Change button's text
				button["textContent"] = "Run";
				
				// Enable button
				button["disabled"] = false;
			});
			
			// Change button's text
			button["textContent"] = "Run";
			
			// Enable button
			button["disabled"] = false;
		});
		
		
		// Supporting function implementation
		
		// Get application information test
		async function getApplicationInformationTest(hardwareWallet) {
		
			// Log message
			console.log("Running get application information test");
		
			// Get the application information from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_APPLICATION_INFORMATION_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Get application name from the response
			let applicationNameDelimiter = findTextDelimiter(response);
			let applicationName = (new TextDecoder()).decode(response.subarray(0, applicationNameDelimiter));
			
			// Log application name
			console.log("Application name: " + applicationName);
			
			// Get application version from the response
			let applicationVersionDelimiter = findTextDelimiter(response.subarray(applicationNameDelimiter + [TEXT_DELIMITER]["length"]));
			let applicationVersion = (new TextDecoder()).decode(response.subarray(applicationNameDelimiter + [TEXT_DELIMITER]["length"]).subarray(0, applicationVersionDelimiter));
									
			// Log application version
			console.log("Application version: " + applicationVersion);
			
			// Log message
			console.log("Passed getting application information test");		
		}
		
		// Get root public key test
		async function getRootPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get root public key test");
			
			// Requestor
			const REQUESTOR = "Test";
		
			// Get the expected root public key from the extended private key
			let expectedRootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Log message
			console.log("Confirm exporting the root public key");
			
			// Get the root public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_ROOT_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
															
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Requestor
				Buffer.from(REQUESTOR)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log root public key
			console.log("Root public key: " + Common.toHexString(response));
			
			// Check if root public key is invalid
			if(Common.arraysAreEqual(response, expectedRootPublicKey) === false) {
			
				// Throw error
				throw "Invalid root public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting root pubic key test");	
		}
		
		// Get public key verification test
		async function getPublicKeyVerificationTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get public key verification test");
			
			// Root public key parameter
			const ROOT_PUBLIC_KEY_PARAMETER = 0;
			
			// Tor public key parameter
			const TOR_PUBLIC_KEY_PARAMETER = ROOT_PUBLIC_KEY_PARAMETER + 1;
			
			// MQS public key parameter
			const MQS_PUBLIC_KEY_PARAMETER = TOR_PUBLIC_KEY_PARAMETER + 1;
			
			// Get the root public key from the extended private key
			let rootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Log message
			console.log("Verify that the root public key is: " + Common.toHexString(rootPublicKey));
			
			// Get root public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, ROOT_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor address from the Tor public key
			let torAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Log message
			console.log("Verify that the Tor public key is: " + torAddress);
			
			// Get Tor public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, TOR_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS address from the MQS public key
			let mqsAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Log message
			console.log("Verify that the MQS public key is: " + mqsAddress);
			
			// Get MQS public key verification from the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_PUBLIC_KEY_VERIFICATION_INSTRUCTION, MQS_PUBLIC_KEY_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Log message
			console.log("Passed getting pubic key verification test");
		}
		
		// Get seed cookie test
		async function getSeedCookieTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get seed cookie test");
			
			// Seed cookie digest algorithm
			const SEED_COOKIE_DIGEST_ALGORITHM = "SHA-512";
			
			// Get the root public key from the extended private key
			let rootPublicKey = await Crypto.rootPublicKey(extendedPrivateKey);
			
			// Get the expected seed cookie from the root public key
			let expectedSeedCookie = new Uint8Array(await crypto["subtle"].digest(SEED_COOKIE_DIGEST_ALGORITHM, rootPublicKey));
			
			// Get seed cookie from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_SEED_COOKIE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log seed cookie
			console.log("Seed cookie: " + Common.toHexString(response));
			
			// Check if seed cookie is invalid
			if(Common.arraysAreEqual(response, expectedSeedCookie) === false) {
			
				// Throw error
				throw "Invalid seed cookie: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting seed cookie test");
		}
		
		// Get commitment test
		async function getCommitmentTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get commitment test");
			
			// Amount
			const AMOUNT = new BigNumber("1234567890");
			
			// Identifier
			const IDENTIFIER = new Identifier("0400000001800000020000000380000004");
			
			// Switch type
			const SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Get the expected commitment from the extended private key, amount, identifier, and switch type
			let expectedCommitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, SWITCH_TYPE);
			
			// Get commitment from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_COMMITMENT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([SWITCH_TYPE]))
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log commitment
			console.log("Commitment: " + Common.toHexString(response));
			
			// Check if commitment is invalid
			if(Common.arraysAreEqual(response, expectedCommitment) === false) {
			
				// Throw error
				throw "Invalid commitment: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting commitment test");
		}
		
		// Get bulletproof test
		async function getBulletproofTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get bulletproof test");
			
			// Amount
			const AMOUNT = new BigNumber("1234567890");
			
			// Identifier
			const IDENTIFIER = new Identifier("0400000001800000020000000380000004");
			
			// Switch type
			const SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Initialize proof builder with the extended private key
			let proofBuilder = new NewProofBuilder();			
			await proofBuilder.initialize(extendedPrivateKey);
			
			// Get expected bulletproof from the extended private key, amount, identifier, switch type, and proof builder
			let expectedBulletproof = await Crypto.proof(extendedPrivateKey, AMOUNT, IDENTIFIER, SWITCH_TYPE, proofBuilder);
			
			// Get bulletproof tau x from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_BULLETPROOF_TAU_X_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([SWITCH_TYPE]))
			]));
			
			// Get tau x from response
			let tauX = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Get bulletproof t one and t two from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_BULLETPROOF_T_ONE_AND_T_TWO_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([SWITCH_TYPE]))
			]));
			
			// Get t one from response
			let tOne = response.subarray(0, Crypto.SECP256K1_PUBLIC_KEY_LENGTH);
			
			// Get t two from response
			let tTwo = response.subarray(Crypto.SECP256K1_PUBLIC_KEY_LENGTH, Crypto.SECP256K1_PUBLIC_KEY_LENGTH + Crypto.SECP256K1_PUBLIC_KEY_LENGTH);
			
			// Get commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, SWITCH_TYPE);
			
			// Get rewind nonce from the proof builder and the commitment
			let rewindNonce = await proofBuilder.rewindNonce(commitment);
			
			// Get proof message from identifier and switch type
			let proofMessage = proofBuilder.proofMessage(IDENTIFIER, SWITCH_TYPE);
			
			// Create bulletproof with the tau x, t one, t two, commit, amount, rewind nonce, and proof message
			let bulletproof = Secp256k1Zkp.createBulletproofBlindless(tauX, tOne, tTwo, commitment, AMOUNT.toFixed(), rewindNonce, new Uint8Array([]), proofMessage);
			
			// Log commitment
			console.log("Bulletproof: " + Common.toHexString(bulletproof));
			
			// Check if commitment is invalid
			if(Common.arraysAreEqual(bulletproof, expectedBulletproof) === false) {
			
				// Throw error
				throw "Invalid bulletproof: " + Common.toHexString(bulletproof);
			}
			
			// Log message
			console.log("Passed getting bulletproof test");
		}
		
		// Get Tor public key test
		async function getTorPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get Tor public key test");
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get expected Tor public key from the Tor private key
			let expectedTorPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get the Tor public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor public key
			console.log("Tor public key: " + Common.toHexString(response));
			
			// Check if Tor public key is invalid
			if(Common.arraysAreEqual(response, expectedTorPublicKey) === false) {
			
				// Throw error
				throw "Invalid Tor public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting Tor pubic key test");	
		}
		
		// Get Tor transaction signature test
		async function getTorTransactionSignatureTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get Tor transaction signature test");
			
			// Amount
			const AMOUNT = new BigNumber("1234567890");
			
			// Identifier
			const IDENTIFIER = new Identifier("0400000001800000020000000380000004");
			
			// Switch type
			const SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Get the commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, SWITCH_TYPE);
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor sender address from the Tor public key
			let torSenderAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Get transaction message from amount, commitment, and Tor sender address
			let transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, torSenderAddress);
			
			// Get the expected Tor transaction signature from the transaction message and Tor private key
			let expectedTorTransactionSignature = Ed25519.sign(transactionMessage, torPrivateKey);
			
			// Get the Tor transaction signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(torSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor transaction signature
			console.log("Tor transaction signature with Tor sender address: " + Common.toHexString(response));
			
			// Check if Tor transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedTorTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid Tor transaction signature: " + Common.toHexString(response);
			}
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS sender address from the MQS public key
			let mqsSenderAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Get transaction message from amount, commitment, and MQS sender address
			transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, mqsSenderAddress);
			
			// Get the expected Tor transaction signature from the transaction message and Tor private key
			expectedTorTransactionSignature = Ed25519.sign(transactionMessage, torPrivateKey);
			
			// Get the Tor transaction signature from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(mqsSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor transaction signature
			console.log("Tor transaction signature with MQS sender address: " + Common.toHexString(response));
			
			// Check if Tor transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedTorTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid Tor transaction signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting Tor transaction signature test");	
		}
		
		// Get Tor certificate signature test
		async function getTorCertificateSignatureTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get Tor certificate signature test");
			
			// Certificate header length
			const CERTIFICATE_HEADER_LENGTH = 32;
			
			// Certificate public key offset
			const CERTIFICATE_PUBLIC_KEY_OFFSET = CERTIFICATE_HEADER_LENGTH + 7;
			
			// Certificate signing public key offset
			const CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET = CERTIFICATE_HEADER_LENGTH + 44;
			
			// Certificate signature offset
			const CERTIFICATE_SIGNATURE_OFFSET = CERTIFICATE_HEADER_LENGTH + 76;
			
			// Certificate (contents of an ed25519_signing_cert file created with the command `tor --keygen --SigningKeyLifetime '6 months'`)
			const CERTIFICATE = Common.fromHexString("3d3d206564323535313976312d636572743a207479706534203d3d0000000000010400070003019e5fd5f3a704fb52aa3e54a835e12ae102d0b44b785f239467a1523ffd4582410100200400b3ee07b33145c47278e7f35468247a4d13905595fe98a533f1b5120609229429fafef1e44a3f25add4570fb3bd0806a9b6a6afeaf32fffd3a40152e5abb6e763069e76ceec0b4027d8a88e37443d304ef963003d44c48c27235f71494778d60d");
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Replace signing public key in certificate with the Tor public key
			let certificate = Common.mergeArrays([CERTIFICATE.subarray(0, CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET), torPublicKey, CERTIFICATE.subarray(CERTIFICATE_SIGNING_PUBLIC_KEY_OFFSET + torPublicKey["length"])]);
			
			// Get the expected Tor certificate signature from the certificate and Tor private key
			let expectedTorCertificateSignature = Ed25519.sign(certificate.subarray(CERTIFICATE_HEADER_LENGTH, CERTIFICATE_SIGNATURE_OFFSET), torPrivateKey);
			
			// Log message
			console.log("Verify that the certificate's public key is: " + Common.toHexString(certificate.subarray(CERTIFICATE_PUBLIC_KEY_OFFSET, CERTIFICATE_PUBLIC_KEY_OFFSET + Crypto.ED25519_PUBLIC_KEY_LENGTH)));
			
			// Get the Tor certificate signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_TOR_CERTIFICATE_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Certificate
				Buffer.from(certificate.subarray(CERTIFICATE_HEADER_LENGTH, CERTIFICATE_SIGNATURE_OFFSET))
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log Tor certificate signature
			console.log("Tor certificate signature: " + Common.toHexString(response));
			
			// Check if Tor certificate signature is invalid
			if(Common.arraysAreEqual(response, expectedTorCertificateSignature) === false) {
			
				// Throw error
				throw "Invalid Tor certificate signature: " + Common.toHexString(response);
			}
			
			// Log signed Tor certificate
			console.log("Signed Tor certificate: " + Common.toHexString(certificate.subarray(0, CERTIFICATE_SIGNATURE_OFFSET)) + Common.toHexString(response));
			
			// Log message
			console.log("Passed getting Tor certificate signature test");	
		}
		
		// Encrypt Slatepack data test
		async function encryptSlatepackDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running encrypt Slatepack data test");
			
			// Data
			const DATA = Common.fromHexString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F");
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get Tor private key from the random private key
			let otherTorPrivateKey = await Crypto.addressKey(Common.mergeArrays([privateKey, crypto.getRandomValues(new Uint8Array(Crypto.CHAIN_CODE_LENGTH))]), TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let otherTorPublicKey = Ed25519.publicKeyFromSecretKey(otherTorPrivateKey);
			
			// Start encrypting Slatepack data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(otherTorPublicKey)
			]));
			
			// Get nonce from response
			let nonce = response.subarray(0, Slatepack.NONCE_LENGTH);
			
			// Go through all chunks of the data
			let encryptedData = new Uint8Array([]);
			for(let i = 0; i <= DATA["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue encrypting Slatepack data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(DATA.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append encrypted data to list
				encryptedData = Common.mergeArrays([encryptedData, response]);
			}
			
			// Finish encrypting Slatepack data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_ENCRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Append tag to encrypted data
			encryptedData = Common.mergeArrays([encryptedData, response]);
			
			// Log encrypted Slatepack data
			console.log("Encrypted Slatepack data: " + Common.toHexString(encryptedData));
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Decrypt the encrypted data
			let decryptedData = await Slatepack.decryptMessage(otherTorPrivateKey, torPublicKey, encryptedData, nonce);
			
			// Log decrypted Slatepack data
			console.log("Decrypted Slatepack data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted Slatepack data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running encrypt Slatepack data test");
		}
		
		// Decrypt Slatepack data test
		async function decryptSlatepackDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running decrypt Slatepack data test");
			
			// Data
			const DATA = Common.fromHexString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F");
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// AES IV size
			const AES_IV_SIZE = 16;
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get Tor private key from the random private key
			let otherTorPrivateKey = await Crypto.addressKey(Common.mergeArrays([privateKey, crypto.getRandomValues(new Uint8Array(Crypto.CHAIN_CODE_LENGTH))]), TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let otherTorPublicKey = Ed25519.publicKeyFromSecretKey(otherTorPrivateKey);
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Encrypt the data
			let encryptedData = await Slatepack.encryptMessage(otherTorPrivateKey, torPublicKey, DATA);
			
			// Log encrypted Slatepack data
			console.log("Encrypted Slatepack data: " + Common.toHexString(encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX]));
			
			// Remove tag from the encrypted data
			let tag = encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] - Slatepack.TAG_LENGTH);
			encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX] = encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(0, encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] - Slatepack.TAG_LENGTH);
			
			// Start decrypting Slatepack data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(otherTorPublicKey),
				
				// Nonce
				Buffer.from(encryptedData[Slatepack.ENCRYPTED_MESSAGE_NONCE_INDEX]),
			]));
			
			// Go through all chunks of the encrypted data
			let decryptedDataChunks = [];
			for(let i = 0; i <= encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue decrypting Slatepack data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(encryptedData[Slatepack.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append decrypted data chunk to list
				decryptedDataChunks.push(response);
			}
			
			// Finish decrypting Slatepack data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_DECRYPTING_SLATEPACK_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(tag));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Create AES key from response
			let aesKey = await crypto.subtle.importKey("raw", response, {"name": "AES-CBC"}, false, ["decrypt"]);
			
			// Go through all decrypted data chunks
			let decryptedData = new Uint8Array([]);
			for(let i = 0; i < decryptedDataChunks["length"]; ++i) {
			
				// Decrypt the data chunk with the AES key
				let data = new Uint8Array(await crypto.subtle.decrypt({"name": "AES-CBC", "iv": new Uint8Array(AES_IV_SIZE)}, aesKey, decryptedDataChunks[i]));
				
				// Append decrypted data chunk to list
				decryptedData = Common.mergeArrays([decryptedData, data]);
			}
			
			// Log decrypted Slatepack data
			console.log("Decrypted Slatepack data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted Slatepack data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running decrypt Slatepack data test");
		}
		
		// Get MQS public key test
		async function getMqsPublicKeyTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get MQS public key test");
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get expected MQS public key from the MQS private key
			let expectedMqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get the MQS public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS public key
			console.log("MQS public key: " + Common.toHexString(response));
			
			// Check if MQS public key is invalid
			if(Common.arraysAreEqual(response, expectedMqsPublicKey) === false) {
			
				// Throw error
				throw "Invalid MQS public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting MQS pubic key test");	
		}
		
		// Get MQS transaction signature test
		async function getMqsTransactionSignatureTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running get MQS transaction signature test");
			
			// Amount
			const AMOUNT = new BigNumber("1234567890");
			
			// Identifier
			const IDENTIFIER = new Identifier("0400000001800000020000000380000004");
			
			// Switch type
			const SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Get the commitment from the extended private key, amount, identifier, and switch type
			let commitment = await Crypto.commit(extendedPrivateKey, AMOUNT, IDENTIFIER, SWITCH_TYPE);
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Get MQS sender address from the MQS public key
			let mqsSenderAddress = Mqs.publicKeyToMqsAddress(mqsPublicKey, Consensus.getNetworkType() === Consensus.MAINNET_NETWORK_TYPE);
			
			// Get transaction message from amount, commitment, and MQS sender address
			let transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, mqsSenderAddress);
			
			// Get transaction message hash from the transaction message
			let transactionMessageHash = new Uint8Array(sha256.arrayBuffer(transactionMessage));
			
			// Get the expected MQS transaction signature from the transaction message hash and MQS private key
			let expectedMqsTransactionSignature = Secp256k1Zkp.createMessageHashSignature(transactionMessageHash, mqsPrivateKey);
			
			// Get the MQS transaction signature from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(mqsSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS transaction signature
			console.log("MQS transaction signature with MQS sender address: " + Common.toHexString(response));
			
			// Check if MQS transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedMqsTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid MQS transaction signature: " + Common.toHexString(response);
			}
			
			// Get Tor private key from the extended private key
			let torPrivateKey = await Crypto.addressKey(extendedPrivateKey, TOR_ADDRESS_KEY_INDEX);
			
			// Get Tor public key from the Tor private key
			let torPublicKey = Ed25519.publicKeyFromSecretKey(torPrivateKey);
			
			// Get Tor sender address from the Tor public key
			let torSenderAddress = Tor.publicKeyToTorAddress(torPublicKey);
			
			// Get transaction message from amount, commitment, and Tor sender address
			transactionMessage = Slate.getPaymentProofMessage(AMOUNT, commitment, torSenderAddress);
			
			// Get transaction message hash from the transaction message
			transactionMessageHash = new Uint8Array(sha256.arrayBuffer(transactionMessage));
			
			// Get the expected MQS transaction signature from the transaction message hash and MQS private key
			expectedMqsTransactionSignature = Secp256k1Zkp.createMessageHashSignature(transactionMessageHash, mqsPrivateKey);
			
			// Get the MQS transaction signature from the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_GET_MQS_TRANSACTION_SIGNATURE_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Amount
				Buffer.from(AMOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Commitment
				Buffer.from(commitment),
				
				// Sender address
				Buffer.from(torSenderAddress)
			]));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log MQS transaction signature
			console.log("MQS transaction signature with Tor sender address: " + Common.toHexString(response));
			
			// Check if MQS transaction signature is invalid
			if(Common.arraysAreEqual(response, expectedMqsTransactionSignature) === false) {
			
				// Throw error
				throw "Invalid MQS transaction signature: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed getting MQS transaction signature test");	
		}
		
		// Encrypt MQS data test
		async function encryptMqsDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running encrypt MQS data test");
			
			// Data
			const DATA = Common.fromHexString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F");
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get public key from the private key
			let publicKey = Secp256k1Zkp.publicKeyFromSecretKey(privateKey);
			
			// Start encrypting MQS data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(publicKey)
			]));
			
			// Get salt from response
			let salt = response.subarray(0, Mqs.SALT_LENGTH);
			
			// Get nonce from response
			let nonce = response.subarray(Mqs.SALT_LENGTH, Mqs.SALT_LENGTH + Mqs.NONCE_LENGTH);
			
			// Go through all chunks of the data
			let encryptedData = new Uint8Array([]);
			for(let i = 0; i <= DATA["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue encrypting MQS data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(DATA.subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append encrypted data to list
				encryptedData = Common.mergeArrays([encryptedData, response]);
			}
			
			// Finish encrypting MQS data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_ENCRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Append tag to encrypted data
			encryptedData = Common.mergeArrays([encryptedData, response]);
			
			// Log encrypted MQS data
			console.log("Encrypted MQS data: " + Common.toHexString(encryptedData));
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Decrypt the encrypted data
			let decryptedData = await Mqs.decryptMessage(privateKey, mqsPublicKey, encryptedData, salt, nonce);
			
			// Log decrypted MQS data
			console.log("Decrypted MQS data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted MQS data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running encrypt MQS data test");
		}
		
		// Decrypt MQS data test
		async function decryptMqsDataTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running decrypt MQS data test");
			
			// Data
			const DATA = Common.fromHexString("000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132333435363738393A3B3C3D3E3F404142434445464748494A4B4C4D4E4F");
			
			// Maximum chunk size
			const MAXIMUM_CHUNK_SIZE = 64;
			
			// AES IV size
			const AES_IV_SIZE = 16;
			
			// While random private key isn't a valid secret key
			let privateKey = new Uint8Array(Crypto.SECP256K1_SECRET_KEY_LENGTH);
			do {
			
				// Fill offset with random values
				crypto.getRandomValues(privateKey);
				
			} while(Secp256k1Zkp.isValidSecretKey(privateKey) === false);
			
			// Get public key from the private key
			let publicKey = Secp256k1Zkp.publicKeyFromSecretKey(privateKey);
			
			// Get MQS private key from the extended private key
			let mqsPrivateKey = await Crypto.addressKey(extendedPrivateKey, MQS_ADDRESS_KEY_INDEX);
			
			// Get MQS public key from the MQS private key
			let mqsPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(mqsPrivateKey);
			
			// Encrypt the data
			let encryptedData = await Mqs.encryptMessage(privateKey, mqsPublicKey, DATA);
			
			// Log encrypted MQS data
			console.log("Encrypted MQS data: " + Common.toHexString(encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX]));
			
			// Remove tag from the encrypted data
			let tag = encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] - Mqs.TAG_LENGTH);
			encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX] = encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(0, encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] - Mqs.TAG_LENGTH);
			
			// Start decrypting MQS data on the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
						
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Public key
				Buffer.from(publicKey),
				
				// Salt
				Buffer.from(encryptedData[Mqs.ENCRYPTED_MESSAGE_SALT_INDEX]),
				
				// Nonce
				Buffer.from(encryptedData[Mqs.ENCRYPTED_MESSAGE_NONCE_INDEX]),
			]));
			
			// Go through all chunks of the encrypted data
			let decryptedDataChunks = [];
			for(let i = 0; i <= encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX]["length"] / MAXIMUM_CHUNK_SIZE; ++i) {
			
				// Continue decrypting MQS data on the hardware wallet
				response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(encryptedData[Mqs.ENCRYPTED_MESSAGE_DATA_INDEX].subarray(i * MAXIMUM_CHUNK_SIZE, i * MAXIMUM_CHUNK_SIZE + MAXIMUM_CHUNK_SIZE)));
				
				// Remove response code from response
				response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
				
				// Append decrypted data chunk to list
				decryptedDataChunks.push(response);
			}
			
			// Finish decrypting MQS data on the hardware wallet
			response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_FINISH_DECRYPTING_MQS_DATA_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.from(tag));
			
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Create AES key from response
			let aesKey = await crypto.subtle.importKey("raw", response, {"name": "AES-CBC"}, false, ["decrypt"]);
			
			// Go through all decrypted data chunks
			let decryptedData = new Uint8Array([]);
			for(let i = 0; i < decryptedDataChunks["length"]; ++i) {
			
				// Decrypt the data chunk with the AES key
				let data = new Uint8Array(await crypto.subtle.decrypt({"name": "AES-CBC", "iv": new Uint8Array(AES_IV_SIZE)}, aesKey, decryptedDataChunks[i]));
				
				// Append decrypted data chunk to list
				decryptedData = Common.mergeArrays([decryptedData, data]);
			}
			
			// Log decrypted MQS data
			console.log("Decrypted MQS data: " + Common.toHexString(decryptedData));
			
			// Check if decrypted data is invalid
			if(Common.arraysAreEqual(decryptedData, DATA) === false) {
			
				// Throw error
				throw "Invalid decrypted MQS data: " + Common.toHexString(decryptedData);
			}
			
			// Log message
			console.log("Passed running decrypt MQS data test");
		}
		
		// Receive transaction test
		async function receiveTransactionTest(hardwareWallet, extendedPrivateKey) {
		
			// Log message
			console.log("Running receive transaction test");
		
			// Output
			const OUTPUT = new BigNumber("1234567890");
			
			// Input
			const INPUT = new BigNumber(0);
			
			// Fee
			const FEE = new BigNumber(0);
			
			// Identifier
			const IDENTIFIER = new Identifier("0400000001800000020000000380000004");
			
			// Switch type
			const SWITCH_TYPE = Crypto.SWITCH_TYPE_REGULAR;
			
			// Get the output's blinding factor
			let outputBlindingFactor = await Crypto.deriveSecretKey(extendedPrivateKey, OUTPUT, IDENTIFIER, SWITCH_TYPE);
			
			// Get the sum of all the transaction's blinding factors
			let transactionBlindingFactor = Secp256k1Zkp.blindSum([outputBlindingFactor], []);
			
			// Get the expected transaction public key from the transaction's blinding factor
			let expectedTransactionPublicKey = Secp256k1Zkp.publicKeyFromSecretKey(transactionBlindingFactor);
		
			// Start transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_START_TRANSACTION_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Account
				Buffer.from(ACCOUNT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT32)),
				
				// Output
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Input
				Buffer.from(INPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Fee
				Buffer.from(FEE.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Receiver address
				Buffer.from([])
			]));
			
			// Include output in the transaction on the hardware wallet
			await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_INCLUDE_OUTPUT_INSTRUCTION, NO_PARAMETER, NO_PARAMETER, Buffer.concat([
			
				// Identifier
				Buffer.from(IDENTIFIER.getValue()),
				
				// Amount
				Buffer.from(OUTPUT.toBytes(BigNumber.LITTLE_ENDIAN, Common.BYTES_IN_A_UINT64)),
				
				// Switch type
				Buffer.from(new Uint8Array([SWITCH_TYPE]))
			]));
			
			// Get the transaction public key from the hardware wallet
			let response = await hardwareWallet.send(REQUEST_CLASS, REQUEST_CONTINUE_TRANSACTION_GET_PUBLIC_KEY_INSTRUCTION, NO_PARAMETER, NO_PARAMETER);
		
			// Remove response code from response
			response = response.subarray(0, response["length"] - RESPONSE_DELIMITER_LENGTH);
			
			// Log transaction public key
			console.log("Transaction public key: " + Common.toHexString(response));
			
			// Check if transaction public key is invalid
			if(Common.arraysAreEqual(response, expectedTransactionPublicKey) === false) {
			
				// Throw error
				throw "Invalid transaction public key: " + Common.toHexString(response);
			}
			
			// Log message
			console.log("Passed running receive transaction test");
		}
		
		// Find text delimiter
		function findTextDelimiter(text) {
		
			// Return finding text delimiter in the text
			return text.findIndex(function(element, index, array) {
			
				// Return if the element is a text delimiter
				return element === TEXT_DELIMITER;
			});
		}
	</script>
	
</head>

<body>

	<p>Open browser's console and click the run button to perform tests</p>
	<button disabled>Loadingâ€¦</button>
	
</body>
</html>
