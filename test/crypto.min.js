"use strict";class Crypto{static deriveChildKey(t,e){return new Promise((function(r,n){var i=t.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),E=t.subarray(Crypto.CHAIN_CODE_LENGTH),c=new Promise((function(t,e){t([i,E])}));for(let t=0;t<e.length;++t)c=c.then((function(r){return i=r[Crypto.SECRET_KEY_INDEX],E=r[Crypto.CHAIN_CODE_INDEX],Crypto.deriveSecretKeyAndChainCode(i,E,e[t])})).catch((function(t){n(t)}));return c.then((function(t){i=t[Crypto.SECRET_KEY_INDEX],E=t[Crypto.CHAIN_CODE_INDEX],r(Common.mergeArrays([i,E]))})).catch((function(t){n(t)}))}))}static commit(t,e,r,n){return new Promise((function(i,E){return Crypto.deriveSecretKey(t,e,r,n).then((function(t){var r=Secp256k1Zkp.pedersenCommit(t,e.toFixed());r!==Secp256k1Zkp.OPERATION_FAILED?i(r):E("Performing Pedersen commit failed.")})).catch((function(t){E(t)}))}))}static commitAmount(t){var e=Secp256k1Zkp.pedersenCommit(Crypto.ZERO_BLINDING_FACTOR,t.toFixed());if(e!==Secp256k1Zkp.OPERATION_FAILED)return e;throw"Performing Pedersen commit failed."}static proof(t,e,r,n,i){return new Promise((function(E,c){return Crypto.commit(t,e,r,n).then((function(a){return Crypto.deriveSecretKey(t,e,r,n).then((function(t){return i.rewindNonce(a).then((function(o){return i.privateNonce(a).then((function(a){try{var _=i.proofMessage(r,n)}catch(t){return void c("Getting proof message failed.")}var C=Secp256k1Zkp.createBulletproof(t,e.toFixed(),o,a,new Uint8Array([]),_);C!==Secp256k1Zkp.OPERATION_FAILED?E(C):c("Getting bulletproof failed.")})).catch((function(t){c(t)}))})).catch((function(t){c(t)}))})).catch((function(t){c(t)}))})).catch((function(t){c(t)}))}))}static deriveSecretKey(t,e,r,n){return new Promise((function(i,E){for(var c=new Uint32Array(r.getDepth()),a=0;a<r.getDepth();++a)c[a]=r.getPaths()[a];return Crypto.deriveChildKey(t,c).then((function(t){var r=t.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH);if(n===Crypto.SWITCH_TYPE_NONE)i(r);else if(n===Crypto.SWITCH_TYPE_REGULAR){var c=Secp256k1Zkp.blindSwitch(r,e.toFixed());if(c===Secp256k1Zkp.OPERATION_FAILED)return void E("Performing blind switch failed.");i(c)}else E("Invalid switch type.")})).catch((function(t){E(t)}))}))}static signatureMessage(t){var e=Blake2b.compute(Crypto.SINGLE_SIGNER_MESSAGE_LENGTH,t,new Uint8Array([]));if(e!==Blake2b.OPERATION_FAILED)return e;throw"Creating signature message failed."}static rootPublicKey(t){return new Promise((function(e,r){var n=t.subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),i=Secp256k1Zkp.publicKeyFromSecretKey(n);i!==Secp256k1Zkp.OPERATION_FAILED?e(i):r("Getting public key failed.")}))}static addressKey(t,e){return new Promise((function(r,n){return Crypto.deriveSecretKey(t,Crypto.ADDRESS_KEY_AMOUNT,new Identifier(Identifier.ROOT_SERIALIZED_IDENTIFIER),Crypto.SWITCH_TYPE_REGULAR).then((function(t){return crypto.subtle.importKey("raw",(new TextEncoder).encode(Crypto.ADDRESS_KEY_SEED),{name:Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,hash:{name:Crypto.ADDRESS_KEY_DIGEST_ALGORITHM}},!1,["sign"]).then((function(i){return crypto.subtle.sign(Crypto.ADDRESS_KEY_ENCRYPTION_ALGORITHM,i,t).then((function(t){var i=(t=new Uint8Array(t)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH),E=t.subarray(Crypto.CHAIN_CODE_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(i))return Crypto.deriveSecretKeyAndChainCode(i,E,e).then((function(t){r(t[Crypto.SECRET_KEY_INDEX])})).catch((function(t){n(t)}));n("Secret key is not a valid secret key.")})).catch((function(t){n(t)}))})).catch((function(t){n(t)}))})).catch((function(t){n(t)}))}))}static get SWITCH_TYPE_NONE(){return 0}static get SWITCH_TYPE_REGULAR(){return Crypto.SWITCH_TYPE_NONE+1}static get SECP256K1_SECRET_KEY_LENGTH(){return 32}static get SECP256K1_PUBLIC_KEY_LENGTH(){return 33}static get BLINDING_FACTOR_LENGTH(){return 32}static get COMMIT_LENGTH(){return 33}static get SINGLE_SIGNER_SIGNATURE_LENGTH(){return 64}static get SINGLE_SIGNER_MESSAGE_LENGTH(){return 32}static get MAXIMUM_PROOF_LENGTH(){return 5134}static get ZERO_BLINDING_FACTOR(){return new Uint8Array(Crypto.BLINDING_FACTOR_LENGTH).fill(0)}static get ED25519_PUBLIC_KEY_LENGTH(){return 32}static get ED25519_SIGNATURE_LENGTH(){return 64}static get MAXIMUM_MESSAGE_HASH_SIGNATURE_LENGTH(){return 72}static get NONCE_LENGTH(){return 32}static get TAU_X_LENGTH(){return 32}static deriveSecretKeyAndChainCode(t,e,r){return new Promise((function(n,i){return crypto.subtle.importKey("raw",e,{name:Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,hash:{name:Crypto.CHAIN_CODE_DIGEST_ALGORITHM}},!1,["sign"]).then((function(E){if(!0===Identifier.isPathHardened(r))var c=Common.mergeArrays([new Uint8Array([0]),t]);else if((c=Secp256k1Zkp.publicKeyFromSecretKey(t))===Secp256k1Zkp.OPERATION_FAILED)return void i("Getting public key from secret key failed.");var a=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT);return new DataView(a).setUint32(0,r,!1),c=Common.mergeArrays([c,new Uint8Array(a)]),crypto.subtle.sign(Crypto.CHAIN_CODE_ENCRYPTION_ALGORITHM,E,c).then((function(r){var E=(r=new Uint8Array(r)).subarray(0,Crypto.SECP256K1_SECRET_KEY_LENGTH);if(!0===Secp256k1Zkp.isValidSecretKey(E)){if((t=Secp256k1Zkp.secretKeyTweakAdd(E,t))===Secp256k1Zkp.OPERATION_FAILED)return void i("Performing secret key tweak add failed.");e=r.subarray(Crypto.CHAIN_CODE_LENGTH),n([t,e])}else i("New secret key is not a valid secret key.")})).catch((function(t){i("Creating new extended private key failed.")}))})).catch((function(t){i("Creating crypto key failed.")}))}))}static get CHAIN_CODE_LENGTH(){return 32}static get SECRET_KEY_INDEX(){return 0}static get CHAIN_CODE_INDEX(){return Crypto.SECRET_KEY_INDEX+1}static get CHAIN_CODE_ENCRYPTION_ALGORITHM(){return"HMAC"}static get CHAIN_CODE_DIGEST_ALGORITHM(){return"SHA-512"}static get ADDRESS_KEY_AMOUNT(){return new BigNumber(713)}static get ADDRESS_KEY_SEED(){return"Grinbox_seed"}static get ADDRESS_KEY_ENCRYPTION_ALGORITHM(){return"HMAC"}static get ADDRESS_KEY_DIGEST_ALGORITHM(){return"SHA-512"}}