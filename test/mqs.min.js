"use strict";class Mqs{static publicKeyToMqsAddress(e,t){var r=Mqs.getAddressVersion(t);return Base58.encodeWithChecksum(Common.mergeArrays([r,e]))}static mqsAddressToPublicKey(e,t){try{var r=Base58.decodeWithChecksum(e)}catch(e){throw"Invalid MQS address."}var n=Mqs.getAddressVersion(t);if(r.length!==n.length+Crypto.SECP256K1_PUBLIC_KEY_LENGTH)throw"Invalid MQS address.";if(!1===Common.arraysAreEqual(r.subarray(0,n.length),n))throw"Invalid MQS address.";if(Secp256k1Zkp.publicKeyFromData(r.subarray(n.length))===Secp256k1Zkp.OPERATION_FAILED)throw"Invalid MQS address.";return r.subarray(n.length)}static encryptMessage(e,t,r){return new Promise((function(n,s){var a=Secp256k1Zkp.publicKeyTweakMultiply(t,e).subarray(1);if(a!==Secp256k1Zkp.OPERATION_FAILED)return crypto.subtle.importKey("raw",a,{name:Mqs.IMPORT_ALGORITHM},!1,["deriveKey"]).then((function(e){var t=new Uint8Array(Mqs.SALT_LENGTH);return crypto.getRandomValues(t),crypto.subtle.deriveKey({name:Mqs.IMPORT_ALGORITHM,salt:t,iterations:Mqs.DIGEST_NUMBER_OF_ITERATIONS,hash:Mqs.DIGEST_ALGORITHM},e,{name:Mqs.ENCRYPTION_ALGORITHM,length:Mqs.ENCRYPTION_KEY_LENGTH},!0,["encrypt","decrypt"]).then((function(e){return crypto.subtle.exportKey("raw",e).then((function(e){if(0!==r.length){var a=new Uint8Array(Mqs.NONCE_LENGTH);crypto.getRandomValues(a);try{var c=chacha.createCipher(new Uint8Array(e),a);c.setAAD(Mqs.AAD_VALUE);var i=c.update(r);c.end();var E=c.getAuthTag();i=Common.mergeArrays([i,E])}catch(e){return void s("Encrypting message failed.")}n([t,a,i])}else s("Invalid message.")})).catch((function(e){s(e)}))})).catch((function(e){s(e)}))})).catch((function(e){s(e)}));s("Creating shared secret failed.")}))}static decryptMessage(e,t,r,n,s){return new Promise((function(a,c){var i=Secp256k1Zkp.publicKeyTweakMultiply(t,e).subarray(1);if(i!==Secp256k1Zkp.OPERATION_FAILED)return crypto.subtle.importKey("raw",i,{name:Mqs.IMPORT_ALGORITHM},!1,["deriveKey"]).then((function(e){return crypto.subtle.deriveKey({name:Mqs.IMPORT_ALGORITHM,salt:n,iterations:Mqs.DIGEST_NUMBER_OF_ITERATIONS,hash:Mqs.DIGEST_ALGORITHM},e,{name:Mqs.ENCRYPTION_ALGORITHM,length:Mqs.ENCRYPTION_KEY_LENGTH},!0,["encrypt","decrypt"]).then((function(e){return crypto.subtle.exportKey("raw",e).then((function(e){if(r.length>Mqs.TAG_LENGTH){try{var t=chacha.createDecipher(new Uint8Array(e),s);t.setAAD(Mqs.AAD_VALUE),t.setAuthTag(r.subarray(r.length-Mqs.TAG_LENGTH));var n=t.update(r.subarray(0,r.length-Mqs.TAG_LENGTH));t.end()}catch(e){return void c("Decrypting message failed.")}a(n)}else c("Invalid encrypted message.")})).catch((function(e){c(e)}))})).catch((function(e){c(e)}))})).catch((function(e){c(e)}));c("Creating shared secret failed.")}))}static get ADDRESS_LENGTH(){return 52}static get ENCRYPTED_MESSAGE_SALT_INDEX(){return 0}static get ENCRYPTED_MESSAGE_NONCE_INDEX(){return Mqs.ENCRYPTED_MESSAGE_SALT_INDEX+1}static get ENCRYPTED_MESSAGE_DATA_INDEX(){return Mqs.ENCRYPTED_MESSAGE_NONCE_INDEX+1}static getAddressVersion(e){switch(Consensus.getWalletType()){case Consensus.MWC_WALLET_TYPE:return!0===e?new Uint8Array([1,69]):new Uint8Array([1,121]);case Consensus.GRIN_WALLET_TYPE:return!0===e?new Uint8Array([1,11]):new Uint8Array([1,120])}}static get IMPORT_ALGORITHM(){return"PBKDF2"}static get ENCRYPTION_ALGORITHM(){return"AES-GCM"}static get ENCRYPTION_KEY_LENGTH(){return 256}static get DIGEST_ALGORITHM(){return"SHA-512"}static get DIGEST_NUMBER_OF_ITERATIONS(){return 100}static get SALT_LENGTH(){return 8}static get NONCE_LENGTH(){return 12}static get TAG_LENGTH(){return 16}static get AAD_VALUE(){return new Uint8Array([])}}